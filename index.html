<!DOCTYPE html>
<html lang="en"> <!-- Added language declaration -->

<head>
    <title>Interactive Astigmatism Wheel: Explore & Visualize Online</title> <!-- Slightly more active title -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"> <!-- Added viewport for mobile -->

    <!-- Basic Metadata -->
    <meta name="author" content="Frincu Madalin">
    <meta name="copyright" content="© 2024 Frincu Madalin. All Rights Reserved.">
    <meta name="license" content="http://creativecommons.org/licenses/by-nc-sa/4.0/">
    <meta name="google-site-verification" content="Nq5VPR_L9XqPIXpH4yenmGVKwdxyMAerw6HSiSwSDcA" />

    <!-- SEO Meta Tags - Enhanced -->
    <meta name="description"
        content="Explore astigmatism with this interactive online wheel visualization. Adjust line count, colors, rotation, anaglyph 3D, zoom/pan, and autopilot modes. A web-based tool for learning and visual exploration, not a medical diagnosis."> <!-- Refined description -->
    <meta name="keywords"
        content="astigmatism, astigmatism wheel, interactive visualization, eye chart simulation, ophthalmology tool, vision visualization, visual acuity, refractive error, anaglyph 3D vision, interactive eye simulation, web-based vision tool, online astigmatism explorer, learn about astigmatism, javascript canvas animation, zoom, pan"> <!-- Expanded keywords -->
    <link rel="canonical" href="https://madalin-fr.github.io/AstigmatismWheelInteraction/">
    <meta name="robots" content="index, follow">

    <!-- Open Graph / Social Media Meta Tags -->
    <meta property="og:title" content="Interactive Astigmatism Wheel Visualization">
    <meta property="og:description"
        content="Explore astigmatism visually with adjustable settings like anaglyph 3D, line count, colors, zoom/pan, and autopilot modes. An interactive learning tool."> <!-- Slightly refined OG desc -->
    <meta property="og:image" content="https://madalin-fr.github.io/AstigmatismWheelInteraction/assets/preview-image-3.png">
    <meta property="og:url" content="https://madalin-fr.github.io/AstigmatismWheelInteraction/">
    <meta property="og:type" content="website">
    <meta property="og:site_name" content="Astigmatism Wheel Interactions"> <!-- Added Site Name -->
    <meta property="og:locale" content="en_US"> <!-- Added Locale -->

    <!-- Twitter Card Meta Tags -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Interactive Astigmatism Wheel Visualization">
    <meta name="twitter:description" content="An interactive online tool to visualize and explore the concepts of astigmatism with various customizable settings including zoom and pan."> <!-- Slightly refined Twitter desc -->
    <meta name="twitter:image" content="https://madalin-fr.github.io/AstigmatismWheelInteraction/assets/preview-image-3.png">
    <!-- <meta name="twitter:site" content="@yourtwitterhandle"> --> <!-- Optional: Add if you have a related Twitter account -->
    <!-- <meta name="twitter:creator" content="@yourtwitterhandle"> --> <!-- Optional: Add if you have a related Twitter account -->

    <style>
        /* Visually hide h1, but keep for SEO/Screen Readers */
        .visually-hidden {
            position: absolute;
            width: 1px;
            height: 1px;
            margin: -1px;
            padding: 0;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            border: 0;
        }

        html,
        body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden; /* Prevent scrollbars */
            background-color: #000000; /* Default BG set via JS, but good to have a fallback */
        }

        canvas {
            position: absolute;
            /* Centering handled by drawing logic relative to width/height */
            /* margin: auto; removed */
            display: block; /* Prevent extra space below canvas */
            /* Accessibility Note: Canvas content is not directly accessible.
               Ensure descriptions and controls provide context. */
            /* Cursor styles handled by JS for panning */
        }

        /* --- Controls Panel Styling --- */
        #controls-container {
            position: absolute;
            /* Default position set via JS/LocalStorage */
            /* top: 1rem; */
            /* left: 1rem; */
            z-index: 10; /* Ensure controls are above canvas */
            display: flex;
            align-items: center;
            gap: 10px;
        }

        #controls-container.reverse {
            flex-direction: row-reverse;
        }

        #drag-handle {
            background-color: rgba(220, 220, 220, 0.8); /* Lighter default handle */
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #666;
            cursor: grab; /* Indicate draggability */
            transition: background-color 0.3s ease, border-color 0.3s ease;
            display: flex; /* Center icon */
            align-items: center;
            justify-content: center;
        }
         #drag-handle:active {
             cursor: grabbing; /* Indicate active drag */
         }

        #drag-handle i { /* Style the icon inside */
            color: #333;
            transition: color 0.3s ease;
        }

        #toggle-menu {
            padding: 8px 15px; /* Adjusted padding */
            border-radius: 4px;
            cursor: pointer;
            border: 1px solid #666;
            background-color: rgba(245, 245, 245, 0.85); /* Slightly off-white */
            color: black;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        #controls {
            display: none; /* Initially hidden, shown by button */
            position: absolute;
             /* Position relative to #controls-container */
             top: calc(100% + 5px); /* Position below the handle/button */
             left: 0; /* Align with left edge */
            background-color: rgba(245, 245, 245, 0.9); /* Slightly more opaque */
            padding: 1rem;
            border-radius: 8px;
            border: 1px solid #ccc;
            max-height: calc(100vh - 6rem); /* Limit height, adjust as needed */
            overflow-y: auto; /* Allow scrolling if content exceeds height */
            width: 250px; /* Fixed width for the panel */
            opacity: 1;
            transition: background-color 0.3s ease, opacity 0.3s ease, border-color 0.3s ease;
            color: black;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1); /* Subtle shadow */
        }

        #controls label {
            display: block; /* Ensure labels are on their own line */
            margin-top: 8px;
            margin-bottom: 2px;
            font-size: 0.9em;
            font-weight: bold;
        }

        #controls input[type='range'],
        #controls select {
            width: 100%;
            margin-bottom: 8px;
        }
         #controls input[type='color'] {
             width: 50px; /* Smaller color swatch */
             height: 25px;
             padding: 0;
             border: 1px solid #ccc;
             vertical-align: middle;
             margin-left: 5px;
         }

        #controls h3 {
            margin: 0 10px 10px 0; /* Adjust margins */
            font-size: 1.1em;
        }

        #controls #toggle-dark-mode,
        #controls #flip-position {
            background: none;
            border: none;
            font-size: 1.4rem;
            padding: 0px;
            cursor: pointer;
            margin: 0 5px; /* Spacing */
            position: relative;
            color: #333;
            transition: color 0.3s ease;
        }
        #controls #toggle-dark-mode i.fa-sun { color: #FFD700; text-shadow: 0 0 2px #fff;}
        #controls #toggle-dark-mode i.fa-moon { color: #4a4a4a; }


        #toggle-autopilot-1,
        #toggle-autopilot-2 {
            padding: 6px 12px; /* Adjusted padding */
            border-radius: 4px;
            cursor: pointer;
            border: 1px solid #666;
            background-color: rgba(220, 220, 220, 0.8); /* Button background */
            color: black;
            transition: all 0.3s ease;
            margin-bottom: 5px;
            width: 100%; /* Make buttons fill width */
            box-sizing: border-box; /* Include padding/border in width */
            font-weight: bold;
        }
         #toggle-autopilot-1.active, /* Style for active autopilot button */
         #toggle-autopilot-2.active {
            background-color: #a8e6cf; /* Example active color */
            border-color: #7fcdb8;
         }

        /* --- Dark Mode Styles --- */
        body.dark-mode-body { background-color: #1a1a1a; } /* Dark body background */

        #controls-container.dark-mode #drag-handle {
            background-color: rgba(50, 50, 50, 0.9);
            border-color: #777;
        }
        #controls-container.dark-mode #drag-handle i { color: #eee; }
        #controls-container.dark-mode #toggle-menu {
            background-color: rgba(40, 40, 40, 0.9);
            color: white;
            border-color: #777;
        }
        #controls.dark-mode {
            background-color: rgba(30, 30, 30, 0.95);
            color: #eee; /* Light text */
            border-color: #555;
        }
        #controls.dark-mode label { color: #ccc; }
        #controls.dark-mode input[type='color'] { border-color: #555; }
        #controls.dark-mode select { background-color: #333; color: #eee; border-color: #555; }
        #controls.dark-mode input[type='range'] { /* Style range sliders for dark mode if needed */ }
        #controls.dark-mode #toggle-dark-mode,
        #controls.dark-mode #flip-position { color: #ccc; }
        #controls.dark-mode #toggle-dark-mode i.fa-moon { color: #FFFF80; text-shadow: 0 0 3px #aaa;}
        #controls.dark-mode #toggle-dark-mode i.fa-sun { color: #777; text-shadow: none;} /* Dim sun in dark mode */
        #controls.dark-mode #toggle-autopilot-1,
        #controls.dark-mode #toggle-autopilot-2 {
            background-color: rgba(60, 60, 60, 0.9);
            color: white;
            border-color: #888;
        }
        #controls.dark-mode #toggle-autopilot-1.active,
        #controls.dark-mode #toggle-autopilot-2.active {
            background-color: #2a5a4a; /* Darker active color */
            border-color: #4a7a6a;
        }

        /* --- Zoom Controls --- */
        #zoom-controls {
            position: absolute;
            top: 1rem;
            right: 1rem;
            z-index: 10;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        #zoom-controls button {
            background-color: rgba(245, 245, 245, 0.85);
            border: 1px solid #666;
            border-radius: 4px;
            padding: 0; /* Remove padding */
            cursor: pointer;
            font-size: 1.2rem; /* Increase font size */
            font-weight: bold;
            color: black;
            transition: all 0.3s ease;
            width: 35px; /* Fixed width */
            height: 35px; /* Fixed height */
            display: flex; /* Center content */
            align-items: center;
            justify-content: center;
            line-height: 1; /* Ensure '+' and '-' center well */
        }

        #zoom-controls button.dark-mode {
            background-color: rgba(40, 40, 40, 0.9);
            color: white;
            border-color: #777;
        }

    </style>
    <!-- External Libraries -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.3.0/css/all.min.css">
    <script src="https://cdn.jsdelivr.net/npm/interactjs/dist/interact.min.js"></script>

    <!-- Structured Data (Schema.org - JSON-LD) -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "WebPage",
      "name": "Interactive Astigmatism Wheel: Explore & Visualize Online",
      "description": "Explore astigmatism with this interactive online wheel visualization. Adjust line count, colors, rotation, anaglyph 3D, zoom/pan, and autopilot modes. A web-based tool for learning and visual exploration, not a medical diagnosis.",
      "url": "https://madalin-fr.github.io/AstigmatismWheelInteraction/",
      "author": {
        "@type": "Person",
        "name": "Frincu Madalin"
      },
      "license": "http://creativecommons.org/licenses/by-nc-sa/4.0/",
      "keywords": "astigmatism, astigmatism wheel, interactive visualization, eye chart simulation, ophthalmology tool, vision visualization, visual acuity, refractive error, anaglyph 3D vision, interactive eye simulation, web-based vision tool, online astigmatism explorer, learn about astigmatism, javascript canvas animation, zoom, pan",
      "mainEntity": {
        "@type": "WebApplication",
        "name": "Astigmatism Wheel Interactions",
        "description": "An interactive web application for visualizing astigmatism concepts using a rotating wheel chart with customizable parameters, zoom/pan, and autopilot features.",
        "applicationCategory": "VisualizationTool",
        "operatingSystem": "Web/Online",
        "browserRequirements": "Requires JavaScript and HTML5 Canvas support.",
        "featureList": [
          "Multiple visualization modes (Many Lines, Single Line, Pendulum, Anaglyph 3D)",
          "Adjustable line count, color, thickness, length",
          "Customizable background and text colors",
          "Anaglyph 3D mode with adjustable depth and eye colors",
          "Interactive rotation control",
          "Autopilot modes for automatic animation (random jumps or smooth transitions)",
          "Zoom and Pan functionality (mouse wheel/drag, touch pinch/drag)",
          "Dark/Light mode toggle",
          "Draggable controls interface"
        ]
        // Add other relevant properties like author, copyrightHolder, license, url, image if desired
      }
    }
    </script>

</head>

<body>
    <!-- Visually Hidden H1 for SEO -->
    <h1 class="visually-hidden">Interactive Astigmatism Wheel: Explore & Visualize Online</h1>

    <!-- Main Content Area -->
    <main>
        <canvas id="canvas">
            <!-- Fallback content for non-supporting browsers -->
            Your browser does not support the HTML5 canvas element. This interactive visualization requires a modern browser with Canvas support.
        </canvas>

        <!-- Controls container -->
        <div id="controls-container" class="draggable">
            <!-- Handle for dragging the entire controls panel -->
            <div id="drag-handle" title="Drag Controls">
                <i class="fas fa-arrows-alt"></i>
            </div>
            <!-- Button to show/hide the main controls panel -->
            <button id="toggle-menu" title="Show/Hide Controls Menu" aria-expanded="false" aria-controls="controls">Show Controls</button>
            <!-- The actual controls panel -->
            <div id="controls" role="region" aria-labelledby="controls-heading" aria-hidden="true">
                <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom: 10px;">
                    <h3 id="controls-heading">Adjust Settings</h3>
                    <!-- Dark mode toggle button -->
                    <button id="toggle-dark-mode" title="Toggle Dark/Light Mode">
                        <i class="fas fa-sun"></i> <!-- Icon changes via JS -->
                    </button>
                    <!-- Button to flip control handle/menu order -->
                    <button id="flip-position" title="Flip Controls Position">
                        <i class="fas fa-exchange-alt"></i>
                    </button>
                </div>

                <label for="visualization-mode">Mode:</label>
                <select id="visualization-mode" style="width: 100%; margin-bottom: 10px;">
                    <option value="many">Many Lines</option>
                    <option value="single">Single Line</option>
                    <option value="pendulum">Pendulum</option>
                    <option value="anaglyph">Anaglyph 3D</option>
                </select>
                <br>

                <label for="opacity-slider">Controls Opacity:</label>
                <input type="range" id="opacity-slider" min="0.1" max="1.0" step="0.1" value="1.0">
                <br>

                <!-- Controls shown/hidden based on mode -->
                <div id="radiating-line-count-container">
                    <label for="radiating-line-count">Radiating Line Count:</label>
                    <input type="range" id="radiating-line-count" min="2" max="72" value="12">
                </div>

                <div id="line-color-container">
                    <label for="line-color">Line Color:</label>
                    <input type="color" id="line-color" value="#7B68EE">
                </div>

                <!-- Label text updated dynamically via JS -->
                <div> <!-- Wrap label/input for better control -->
                    <label for="special-line-color" id="special-line-color-label">Special Line Color:</label>
                    <input type="color" id="special-line-color" value="#FFFFFF">
                </div>
                <br>

                <!-- Anaglyph Specific Controls -->
                <div id="anaglyph-color-pickers" style="display: none;">
                    <label for="anaglyph-left-color">Left Eye Color:</label>
                    <input type="color" id="anaglyph-left-color" value="#ff0000">
                    <br>
                    <label for="anaglyph-right-color">Right Eye Color:</label>
                    <input type="color" id="anaglyph-right-color" value="#00ffff">
                    <br>
                </div>
                <div id="depth-offset-container" style="display: none;">
                    <label for="depth-offset">Anaglyph Depth Offset:</label>
                    <input type="range" id="depth-offset" min="-50" max="50" value="5"> <!-- Allow negative depth -->
                    <br>
                </div>
                <!-- End Anaglyph Specific -->

                <!-- Pendulum Specific Controls -->
                <div id="pendulum-size-container" style="display: none;">
                    <label for="pendulum-thickness">Pendulum Thickness:</label>
                    <input type="range" id="pendulum-thickness" min="1" max="500" value="20">
                </div>
                <!-- End Pendulum Specific -->


                <label for="bg-color">Background Color:</label>
                <input type="color" id="bg-color" value="#000000"> <!-- Initial value overridden by JS/LocalStorage -->
                <br>

                <label for="text-color">Text Color:</label>
                <input type="color" id="text-color" value="#FFFFFF"> <!-- Initial value overridden by JS/LocalStorage -->
                <br>

                <label for="circle-outline-color">Circle Outline Color:</label>
                <input type="color" id="circle-outline-color" value="#ffffff"> <!-- Initial value overridden by JS/LocalStorage -->
                <br>

                <!-- Pan Controls (Now control originX/Y) -->
                <label for="horizontal-offset">Horizontal Pan:</label>
                <input type="range" id="horizontal-offset" min="-2000" max="2000" value="0" step="10"> <!-- Range set dynamically -->
                <br>
                <label for="vertical-offset">Vertical Pan:</label>
                <input type="range" id="vertical-offset" min="-2000" max="2000" value="0" step="10"> <!-- Range set dynamically -->
                <br>
                <!-- End Pan Controls -->

                <label for="arc-offset">Circle Radius Offset:</label>
                <input type="range" id="arc-offset" min="-200" max="1200" value="0">
                <br>
                <label for="circle-outline-dash-density">Arc Dash Density:</label>
                <input type="range" id="circle-outline-dash-density" min="1" max="48" value="15">
                <br>
                <label for="text-size">Text Size (px):</label>
                <input type="range" id="text-size" min="8" max="72" value="14">
                <br>
                <label for="text-distance">Text Distance (Factor):</label>
                <input type="range" id="text-distance" min="1.0" max="5.0" step="0.1" value="1.6">
                <br>

                <label for="line-thickness">Line Thickness:</label>
                <input type="range" id="line-thickness" min="1" max="40" value="4">
                <br>
                <label for="line-length">Line Length (Factor):</label>
                <input type="range" id="line-length" min="0.1" max="4.0" step="0.1" value="1.0">
                <br>

                <!-- MOVED ROTATION CHECKBOXES HERE -->
                <label for="rotation-velocity">Rotation Velocity:</label>
                <input type="range" id="rotation-velocity" min="0.1" max="10" step="0.1" value="1">
                <br>
                <div style="margin-top: 5px; margin-bottom: 10px;"> <!-- Adjusted margin -->
                    <input type="checkbox" id="rotate-clockwise" checked>
                    <label for="rotate-clockwise" style="display: inline; margin: 0 5px 0 0;">Rotate Clockwise</label> <br>
                    <input type="checkbox" id="rotate-counterclockwise">
                    <label for="rotate-counterclockwise" style="display: inline; margin: 0 5px 0 0;">Rotate Counter-Clockwise</label>
                </div>
                <!-- END MOVED ROTATION CHECKBOXES -->

                <label for="autopilot-speed">Autopilot Speed:</label>
                <input type="range" id="autopilot-speed" min="5" max="40" value="10">
                <br>
                <!-- Autopilot Walk Range Control (influences target offset calculation) -->
                <label for="autopilot-walk-range">Autopilot Pan Range (% Width/Height):</label>
                <input type="range" id="autopilot-walk-range" min="0" max="90" value="30">
                <br>

                <!-- Autopilot Toggles -->
                <div style="margin-top: 10px;"> <!-- Add spacing -->
                    <button id="toggle-autopilot-1" title="Start/Stop Autopilot Mode 1 (Smooth Rotation, Random Jumps)">Start Autopilot 1</button>
                </div>
                <div>
                    <button id="toggle-autopilot-2" title="Start/Stop Autopilot Mode 2 (Smooth Rotation, Smooth Transitions)">Start Autopilot 2</button>
                </div>

            </div>
        </div>

        <!-- Zoom controls -->
        <div id="zoom-controls">
            <button id="zoom-in" title="Zoom In (+)">+</button>
            <button id="zoom-out" title="Zoom Out (-)">-</button>
        </div>

    </main> <!-- End Main Content Area -->

    <script>
        // --- Utility Functions ---

        /**
         * Standardizes a color string (e.g., 'blue', '#f00', 'rgb(255,0,0)')
         * into a lowercase 6-digit hex format (e.g., '#ff0000') using the canvas API.
         * @param {string} str - The color string to standardize.
         * @returns {string} The standardized hex color string, or the original if parsing fails.
         */
        function standardize_color(str) {
            // Optimization: If already hex6, return early
            if (typeof str === 'string' && /^#[0-9a-f]{6}$/i.test(str)) {
                return str.toLowerCase();
            }
            try {
                // Use a temporary canvas context to parse the color
                var ctx = document.createElement('canvas').getContext('2d');
                ctx.fillStyle = str;
                let standardized = ctx.fillStyle;
                // Ensure it's lowercase hex6 if possible
                if (standardized.startsWith('#') && standardized.length === 7) {
                    return standardized.toLowerCase();
                }
                 // If canvas returns rgb/rgba etc., return that as fallback (though hex is preferred)
                return standardized;
            } catch (e) {
                 console.warn("Could not standardize color:", str, e);
                 return str; // Return original on error
            }
        }

        /**
         * Sets the background color of the HTML body.
         * @param {string} color - A valid CSS color string.
         */
        function setBackgroundColor(color) {
            document.body.style.backgroundColor = color;
        }

        // --- Local Storage Functions ---

        /**
         * Safely retrieves a value from localStorage.
         * @param {string} key - The key to retrieve.
         * @returns {string | null} The retrieved value, or null if not found or error.
         */
        function getLocalStorageValue(k) {
            try {
                return localStorage.getItem(k);
            } catch (error) {
                console.error("Error reading from localStorage:", k, error);
                return null;
            }
        }

        /**
         * Safely saves a value to localStorage.
         * @param {string} key - The key to save under.
         * @param {string} value - The value to save.
         */
        function setLocalStorageValue(k, v) {
            try {
                localStorage.setItem(k, String(v)); // Ensure value is string
            } catch (error) {
                 console.error("Error writing to localStorage:", k, v, error);
                 // Consider handling QuotaExceededError specifically if needed
            }
        }

        /**
         * Initializes a localStorage key with a default value if it doesn't exist.
         * @param {string} key - The key to initialize.
         * @param {string} defaultValue - The default value to set.
         */
        function initializeLocalStorage(key, defaultValue) {
            if (getLocalStorageValue(key) === null) {
                setLocalStorageValue(key, defaultValue);
            }
        }

        /**
         * Converts an angle (0-360) to its corresponding label on the astigmatism wheel (0°-180°).
         * Uses integer degrees for display.
         * @param {number} num - The angle in degrees (0-360).
         * @returns {string} The formatted angle label (e.g., "90°").
         */
        function angleName(num) {
             // Normalize angle to be strictly within [0, 360)
            num = ((num % 360) + 360) % 360;

            // Map to 0-180 range for display
            let displayAngle;
            if (num >= 0 && num < 180) {
                 displayAngle = num;
            } else { // 180 to 359.99...
                 displayAngle = num - 180;
            }

            // Special case for angles very close to 0 or 180 for precision
            if (Math.abs(displayAngle) < 0.01 || Math.abs(displayAngle - 180) < 0.01) {
                return "0°";
            } else if (Math.abs(displayAngle - 90) < 0.01) {
                return "90°"
            } else {
                 return Math.round(displayAngle) + "°";
            }
        }


        // --- Initialization and Setup ---

        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d", { alpha: false }); // Optimize if no transparency needed behind canvas
        context.imageSmoothingEnabled = true; // Enable anti-aliasing by default

        // Canvas dimensions (updated on resize)
        let canvasHeight = window.innerHeight;
        let canvasWidth = window.innerWidth;
        canvas.width = canvasWidth;
        canvas.height = canvasHeight;

        // Base radius for drawing elements (updated on resize)
        let radius = Math.min(canvasWidth, canvasHeight) / 4.5; // Slightly smaller for padding

        // --- Zoom and Pan Functionality ---
        let scale = 1.0;                // Current zoom level
        const minScale = 0.1;           // Minimum zoom out
        const maxScale = 10.0;          // Maximum zoom in
        let zoomFactor = 1.1;           // How much to zoom per step
        // originX/Y represent the translation offset in the canvas transform.
        // These are controlled by panning (mouse/touch drag) and the Pan sliders.
        let originX = 0;
        let originY = 0;
        let isDragging = false;         // Is the user currently dragging the canvas?
        let isPinching = false;         // Is the user currently pinch-zooming?
        let lastX = 0;                  // Last mouse/touch X for drag calculation
        let lastY = 0;                  // Last mouse/touch Y for drag calculation
        let pinchStartDistance = 0;     // Initial distance between fingers for pinch zoom


        // --- Default Settings & LocalStorage Initialization ---
        const defaultSettings = {
            mode: 'many',
            // Colors (standardized to lowercase hex6)
            color_many: '#7b68ee', color2_many: '#ffffff',
            color_single: '#ffffff', color2_single: '#ffffff', // color2 used for single line
            color_pendulum: '#ffd700', color2_pendulum: '#c0c0c0',
            color3: '#ffffff', // Circle Outline (common)
            anaglyphLeftColor: '#ff0000', anaglyphRightColor: '#00ffff',
            bgColor_many: '#000000', bgColor_single: '#000000',
            bgColor_pendulum: '#2f4f4f', bgColor_anaglyph: '#000000',
            textColor_many: '#ffffff', textColor_single: '#ffffff',
            textColor_pendulum: '#ffffff', textColor_anaglyph: '#ffffff', // Drawn twice
            // Numeric/Boolean settings
            textSize: '14',
            pendulumThickness: '20',
            textDistance: '1.6',
            startAngle: '0',
            // horizontalOffset, verticalOffset are deprecated -> use originX, originY
            originX: '0', // Default pan X
            originY: '0', // Default pan Y
            arcOffset: '0',
            rotationVelocity: '1.0',
            lineLength: '1.0',
            isDarkMode: 'true', // Default to dark mode
            isReversed: 'false', // Controls layout LTR/RTL
            lineThickness: '4',
            radiatingLineCount: '12', // Clock face default
            autopilotSpeed: '10',
            rotateClockwise: 'true',
            rotateCounterclockwise: 'false',
            opacity: '0.9', // Controls panel opacity
            autopilotWalkRange: '30', // Percentage for autopilot panning range
            controlsPosition: JSON.stringify({ x: 16, y: 16 }), // Default controls pos (top-left)
            circleOutlineDashDensity: '15',
            depthOffset: '5', // Anaglyph depth
            // scale: '1.0', // Could save scale too, but start at 1 for now
        };

        // Initialize LS keys *before* retrieving values
        for (const key in defaultSettings) {
            initializeLocalStorage(key, defaultSettings[key]);
        }

        // --- Load Settings from LocalStorage ---

        // Helper to get mode-specific settings, falling back to defaults
        function getModeSetting(baseKey, currentMode) {
             const modeSpecificKey = `${baseKey}_${currentMode}`;
             const value = getLocalStorageValue(modeSpecificKey);
             if (value !== null) return value; // Return stored value if exists
             if (defaultSettings[modeSpecificKey] !== undefined) return defaultSettings[modeSpecificKey]; // Fallback mode default
             console.warn(`No specific or default setting found for ${modeSpecificKey}`);
             return defaultSettings[baseKey] || null; // Absolute fallback or null
        }

        // Load settings, using defaults from defaultSettings object if not found in LS
        let mode = getLocalStorageValue('mode') || defaultSettings.mode;
        let color = standardize_color(getModeSetting('color', mode));
        let color2 = standardize_color(getModeSetting('color2', mode));
        let color3 = standardize_color(getLocalStorageValue('color3') || defaultSettings.color3);
        let bgColor = standardize_color(getModeSetting('bgColor', mode));
        let textColor = standardize_color(getModeSetting('textColor', mode));
        let anaglyphLeftColor = standardize_color(getLocalStorageValue('anaglyphLeftColor') || defaultSettings.anaglyphLeftColor);
        let anaglyphRightColor = standardize_color(getLocalStorageValue('anaglyphRightColor') || defaultSettings.anaglyphRightColor);

        let textSize = parseInt(getLocalStorageValue('textSize') || defaultSettings.textSize);
        let pendulumThickness = parseInt(getLocalStorageValue('pendulumThickness') || defaultSettings.pendulumThickness);
        let textDistance = parseFloat(getLocalStorageValue('textDistance') || defaultSettings.textDistance);
        let startAngle = parseFloat(getLocalStorageValue('startAngle') || defaultSettings.startAngle);
        originX = parseFloat(getLocalStorageValue('originX') || defaultSettings.originX); // Load pan X
        originY = parseFloat(getLocalStorageValue('originY') || defaultSettings.originY); // Load pan Y
        let arcOffset = parseInt(getLocalStorageValue('arcOffset') || defaultSettings.arcOffset);
        let rotationVelocity = parseFloat(getLocalStorageValue('rotationVelocity') || defaultSettings.rotationVelocity);
        let lineLength = parseFloat(getLocalStorageValue('lineLength') || defaultSettings.lineLength);
        let isDarkMode = (getLocalStorageValue('isDarkMode') || defaultSettings.isDarkMode) === 'true';
        let isReversed = (getLocalStorageValue('isReversed') || defaultSettings.isReversed) === 'true';
        let lineThickness = parseInt(getLocalStorageValue('lineThickness') || defaultSettings.lineThickness);
        let radiatingLineCount = parseInt(getLocalStorageValue('radiatingLineCount') || defaultSettings.radiatingLineCount);
        let autopilotSpeed = parseInt(getLocalStorageValue('autopilotSpeed') || defaultSettings.autopilotSpeed);
        let rotateClockwise = (getLocalStorageValue('rotateClockwise') || defaultSettings.rotateClockwise) === 'true';
        let rotateCounterclockwise = (getLocalStorageValue('rotateCounterclockwise') || defaultSettings.rotateCounterclockwise) === 'true';
        let opacity = parseFloat(getLocalStorageValue('opacity') || defaultSettings.opacity);
        let autopilotWalkRange = parseInt(getLocalStorageValue('autopilotWalkRange') || defaultSettings.autopilotWalkRange);
        let circleOutlineDashDensity = parseInt(getLocalStorageValue('circleOutlineDashDensity') || defaultSettings.circleOutlineDashDensity);
        let depthOffset = parseInt(getLocalStorageValue('depthOffset') || defaultSettings.depthOffset);
        // scale = parseFloat(getLocalStorageValue('scale') || defaultSettings.scale); // Load scale if saved

        // Initialize pendulum angle (use startAngle if specific pendulum angle not saved)
        let pendulumAngle = parseFloat(getLocalStorageValue('pendulumAngle') || startAngle);

        // --- DOM Element References ---
        const controlsContainer = document.getElementById('controls-container');
        const controls = document.getElementById('controls');
        const toggleMenuButton = document.getElementById('toggle-menu');
        const flipPositionButton = document.getElementById('flip-position');
        const horizontalOffsetSlider = document.getElementById('horizontal-offset'); // Now the Pan X slider
        const verticalOffsetSlider = document.getElementById('vertical-offset');     // Now the Pan Y slider
        const autopilotWalkRangeSlider = document.getElementById('autopilot-walk-range');
        const toggleDarkModeButton = document.getElementById('toggle-dark-mode');
        const toggleAutopilot1Button = document.getElementById("toggle-autopilot-1");
        const toggleAutopilot2Button = document.getElementById("toggle-autopilot-2");
        const rotateClockwiseToggle = document.getElementById('rotate-clockwise');
        const rotateCounterClockwiseToggle = document.getElementById('rotate-counterclockwise');
        // ... (add other element refs if needed frequently)


        // --- UI Initialization Function ---

        /**
         * Sets the min/max range for the pan sliders based on canvas dimensions.
         * Allows panning roughly one screen width/height away from center.
         */
        function updatePanSliderLimits() {
            const maxPanX = canvasWidth; // Allow panning full width off screen
            const maxPanY = canvasHeight; // Allow panning full height off screen
            horizontalOffsetSlider.min = -maxPanX;
            horizontalOffsetSlider.max = maxPanX;
            verticalOffsetSlider.min = -maxPanY;
            verticalOffsetSlider.max = maxPanY;

            // Clamp current origin to new limits *after* setting them
            originX = Math.max(parseFloat(horizontalOffsetSlider.min), Math.min(originX, parseFloat(horizontalOffsetSlider.max)));
            originY = Math.max(parseFloat(verticalOffsetSlider.min), Math.min(originY, parseFloat(verticalOffsetSlider.max)));

            // Update sliders if clamping occurred (important for consistency)
            horizontalOffsetSlider.value = originX;
            verticalOffsetSlider.value = originY;
        }

        function initializeUI() {
            // Set control values from loaded settings
            document.getElementById('line-color').value = color;
            document.getElementById('special-line-color').value = color2;
            document.getElementById('circle-outline-color').value = color3;
            document.getElementById('bg-color').value = bgColor;
            document.getElementById('text-color').value = textColor;
            document.getElementById('line-thickness').value = lineThickness;
            document.getElementById('radiating-line-count').value = radiatingLineCount;
            // Set Pan Slider values FIRST
            horizontalOffsetSlider.value = originX;
            verticalOffsetSlider.value = originY;
            // THEN set their limits (which might clamp the values)
            updatePanSliderLimits(); // Set dynamic pan slider limits
            document.getElementById('arc-offset').value = arcOffset;
            document.getElementById('line-length').value = lineLength;
            document.getElementById('text-size').value = textSize;
            document.getElementById('pendulum-thickness').value = pendulumThickness;
            document.getElementById('text-distance').value = textDistance;
            document.getElementById('rotation-velocity').value = rotationVelocity;
            document.getElementById('autopilot-speed').value = autopilotSpeed;
            rotateClockwiseToggle.checked = rotateClockwise;
            rotateCounterClockwiseToggle.checked = rotateCounterclockwise;
            document.getElementById('opacity-slider').value = opacity;
            document.getElementById('visualization-mode').value = mode;
            autopilotWalkRangeSlider.value = autopilotWalkRange; // Autopilot range setting
            document.getElementById('circle-outline-dash-density').value = circleOutlineDashDensity;
            document.getElementById('depth-offset').value = depthOffset;
            document.getElementById('anaglyph-left-color').value = anaglyphLeftColor;
            document.getElementById('anaglyph-right-color').value = anaglyphRightColor;

            // Apply initial visual state
            setBackgroundColor(bgColor);
            applyDarkMode(isDarkMode); // Apply dark/light mode styles
            controls.style.opacity = opacity;
            toggleControlVisibility(); // Show/hide controls based on mode
            updateTextPlaceholder(); // Update dynamic labels

            // Position controls container based on saved position
            const savedPosition = JSON.parse(getLocalStorageValue('controlsPosition') || defaultSettings.controlsPosition);
            controlsContainer.style.transform = `translate(${savedPosition.x}px, ${savedPosition.y}px)`;
            controlsContainer.setAttribute('data-x', savedPosition.x);
            controlsContainer.setAttribute('data-y', savedPosition.y);
            if (isReversed) {
                controlsContainer.classList.add('reverse');
            }

            // Initialize Pan/Zoom event listeners
            initializeZoomAndPan();

            // Apply initial canvas transform (scale and pan) and draw
            updateCanvasTransform();
        }

        // --- Run Initialization ---
        // Use DOMContentLoaded for reliability
        document.addEventListener('DOMContentLoaded', initializeUI);


        // --- Draggable Controls Panel (InteractJS) ---
        interact('.draggable').draggable({
            allowFrom: '#drag-handle', // Only allow dragging from the handle
            inertia: true, // Add some inertia for smoother feel
            modifiers: [
                interact.modifiers.restrictRect({
                    // Restrict dragging to the viewport bounds dynamically
                    restriction: () => {
                        const viewportWidth = window.innerWidth;
                        const viewportHeight = window.innerHeight;
                        // Return a rectangle representing the viewport
                        return { x: 0, y: 0, width: viewportWidth, height: viewportHeight };
                    },
                    // Apply restriction during drag, not just at the end
                    endOnly: false
                })
            ],
            autoScroll: false, // Disable auto-scrolling
            listeners: {
                move(event) { // Fired during drag
                    const target = event.target;
                    // Keep track of the position using data attributes
                    const x = (parseFloat(target.getAttribute('data-x')) || 0) + event.dx;
                    const y = (parseFloat(target.getAttribute('data-y')) || 0) + event.dy;

                    // Apply the translation via CSS transform
                    target.style.transform = `translate(${x}px, ${y}px)`;

                    // Update the data attributes
                    target.setAttribute('data-x', x);
                    target.setAttribute('data-y', y);
                },
                end(event) { // Fired when drag ends
                     // Save the final position to localStorage
                     const target = event.target;
                     const x = parseFloat(target.getAttribute('data-x')) || 0;
                     const y = parseFloat(target.getAttribute('data-y')) || 0;
                     setLocalStorageValue('controlsPosition', JSON.stringify({ x: x, y: y }));
                }
            }
        });


        // --- General Controls Event Listeners ---

        // Toggle Controls Panel Visibility
        toggleMenuButton.addEventListener('click', () => {
            const isVisible = controls.style.display === 'block';
            controls.style.display = isVisible ? 'none' : 'block';
            toggleMenuButton.textContent = isVisible ? 'Show Controls' : 'Hide Controls';
            toggleMenuButton.setAttribute('aria-expanded', !isVisible);
            controls.setAttribute('aria-hidden', isVisible);
        });
        // Set initial ARIA state
        toggleMenuButton.setAttribute('aria-expanded', controls.style.display === 'block');
        controls.setAttribute('aria-hidden', controls.style.display !== 'block');

        // Flip Controls Handle/Menu Order
        flipPositionButton.addEventListener('click', () => {
            isReversed = !isReversed;
            setLocalStorageValue('isReversed', isReversed); // Save preference
            controlsContainer.classList.toggle('reverse');
        });


        // --- Input Element Event Handling (Sliders, Pickers, Select) ---
        const inputElementIds = [
            'visualization-mode', 'horizontal-offset', 'pendulum-thickness', 'vertical-offset',
            'arc-offset', 'line-length', 'rotation-velocity', 'line-thickness',
            'radiating-line-count', 'line-color', 'special-line-color', 'text-size',
            'text-distance', 'bg-color', 'text-color', 'circle-outline-color',
            'opacity-slider', 'autopilot-walk-range', 'circle-outline-dash-density',
            'depth-offset', 'anaglyph-left-color', 'anaglyph-right-color'
        ];

        inputElementIds.forEach(id => {
            const element = document.getElementById(id);
            if (!element) {
                console.warn(`Element with ID '${id}' not found.`);
                return;
            }
            element.addEventListener('input', function () {
                 let needsRedraw = true; // Assume redraw needed unless specified otherwise
                 let updateTransform = false; // Flag if transform needs update

                switch (id) {
                    case 'visualization-mode':
                         mode = this.value;
                         setLocalStorageValue('mode', mode);
                         // Load/apply settings specific to the new mode
                         color = standardize_color(getModeSetting('color', mode));
                         color2 = standardize_color(getModeSetting('color2', mode));
                         bgColor = standardize_color(getModeSetting('bgColor', mode));
                         textColor = standardize_color(getModeSetting('textColor', mode));
                         // Update UI elements for the new mode
                         applyColorsToControls();
                         setBackgroundColor(bgColor);
                         toggleControlVisibility();
                         updateTextPlaceholder();
                         needsRedraw = true;
                         break;

                    // PAN SLIDERS - Update originX/Y and trigger transform update
                    case 'horizontal-offset':
                        originX = parseFloat(this.value);
                        setLocalStorageValue('originX', originX);
                        updateTransform = true;
                        needsRedraw = false; // updateCanvasTransform handles redraw
                        break;
                    case 'vertical-offset':
                        originY = parseFloat(this.value);
                        setLocalStorageValue('originY', originY);
                        updateTransform = true;
                        needsRedraw = false; // updateCanvasTransform handles redraw
                        break;

                    // Other visual parameter updates
                    case 'pendulum-thickness': pendulumThickness = parseInt(this.value); setLocalStorageValue('pendulumThickness', pendulumThickness); break;
                    case 'arc-offset': arcOffset = parseInt(this.value); setLocalStorageValue('arcOffset', arcOffset); break;
                    case 'line-length': lineLength = parseFloat(this.value); setLocalStorageValue('lineLength', lineLength); break;
                    case 'rotation-velocity': rotationVelocity = parseFloat(this.value); setLocalStorageValue('rotationVelocity', rotationVelocity); break;
                    case 'line-thickness': lineThickness = parseInt(this.value); setLocalStorageValue('lineThickness', lineThickness); break;
                    case 'radiating-line-count': radiatingLineCount = parseInt(this.value); setLocalStorageValue('radiatingLineCount', radiatingLineCount); break; // Corrected LS Key
                    case 'text-size': textSize = parseInt(this.value); setLocalStorageValue('textSize', textSize); break;
                    case 'text-distance': textDistance = parseFloat(this.value); setLocalStorageValue('textDistance', textDistance); break;
                    case 'circle-outline-dash-density': circleOutlineDashDensity = parseInt(this.value); setLocalStorageValue('circleOutlineDashDensity', circleOutlineDashDensity); break;
                    case 'depth-offset': depthOffset = parseInt(this.value); setLocalStorageValue('depthOffset', depthOffset); needsRedraw = (mode === 'anaglyph'); break;

                    // Color updates (store per mode where applicable)
                    case 'line-color': color = standardize_color(this.value); setLocalStorageValue('color_' + mode, color); break;
                    case 'special-line-color': color2 = standardize_color(this.value); setLocalStorageValue('color2_' + mode, color2); break;
                    case 'text-color': textColor = standardize_color(this.value); setLocalStorageValue('textColor_' + mode, textColor); break;
                    case 'circle-outline-color': color3 = standardize_color(this.value); setLocalStorageValue('color3', color3); break; // Common setting
                    case 'anaglyph-left-color': anaglyphLeftColor = standardize_color(this.value); setLocalStorageValue('anaglyphLeftColor', anaglyphLeftColor); needsRedraw = (mode === 'anaglyph'); break;
                    case 'anaglyph-right-color': anaglyphRightColor = standardize_color(this.value); setLocalStorageValue('anaglyphRightColor', anaglyphRightColor); needsRedraw = (mode === 'anaglyph'); break;

                    case 'bg-color':
                        bgColor = standardize_color(this.value);
                        setLocalStorageValue('bgColor_' + mode, bgColor);
                        setBackgroundColor(bgColor);
                        // Optional: Auto-calculate anaglyph colors based on BG
                        // if (mode === 'anaglyph' && shouldAutoCalcAnaglyph) { ... }
                        break;

                    // Non-drawing updates
                    case 'opacity-slider':
                        opacity = parseFloat(this.value);
                        setLocalStorageValue('opacity', opacity);
                        controls.style.opacity = opacity;
                        needsRedraw = false;
                        break;
                    case 'autopilot-walk-range':
                        autopilotWalkRange = parseInt(this.value);
                        setLocalStorageValue('autopilotWalkRange', autopilotWalkRange);
                        needsRedraw = false; // Doesn't directly affect drawing unless autopilot recalculates target
                        break;
                 }

                // Apply canvas transform if needed (for pan sliders)
                if (updateTransform) {
                    updateCanvasTransform();
                }
                // Request redraw if needed and not animating or handled by transform update
                else if (needsRedraw && !shouldAnimate) {
                     requestAnimationFrame(draw); // Use rAF for efficiency
                }
            });
        });

        // Helper to update the color picker UI elements
        function applyColorsToControls() {
            document.getElementById('line-color').value = color;
            document.getElementById('special-line-color').value = color2;
            document.getElementById('bg-color').value = bgColor;
            document.getElementById('text-color').value = textColor;
            document.getElementById('circle-outline-color').value = color3;
            document.getElementById('anaglyph-left-color').value = anaglyphLeftColor;
            document.getElementById('anaglyph-right-color').value = anaglyphRightColor;
        }


        // --- Resize and Key Event Handling ---

        window.addEventListener("resize", function () {
            // Update canvas dimensions
            canvasWidth = window.innerWidth;
            canvasHeight = window.innerHeight;
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;

            // Recalculate base radius
            radius = Math.min(canvasWidth, canvasHeight) / 4.5;

            // --- Clamp Controls Panel Position ---
            // Ensure the control panel doesn't get stuck off-screen after resize
            const currentX = parseFloat(controlsContainer.getAttribute('data-x')) || 0;
            const currentY = parseFloat(controlsContainer.getAttribute('data-y')) || 0;
            const panelRect = controlsContainer.getBoundingClientRect(); // Get current size
            const panelWidth = panelRect.width || 280; // Use measured or fallback width
            const panelHeight = panelRect.height || 50; // Use measured or fallback height

            const maxX = window.innerWidth - panelWidth - 5; // Max X (top-left) with padding
            const maxY = window.innerHeight - panelHeight - 5; // Max Y (top-left) with padding

            // Clamp position to be within new viewport bounds
            const clampedX = Math.max(0, Math.min(currentX, maxX));
            const clampedY = Math.max(0, Math.min(currentY, maxY));

            // Apply clamped position if it changed
            if (clampedX !== currentX || clampedY !== currentY) {
                controlsContainer.style.transform = `translate(${clampedX}px, ${clampedY}px)`;
                controlsContainer.setAttribute('data-x', clampedX);
                controlsContainer.setAttribute('data-y', clampedY);
                setLocalStorageValue('controlsPosition', JSON.stringify({ x: clampedX, y: clampedY }));
            }
            // --- End Clamp Controls Panel ---

            // Update Pan Slider Limits on resize
            updatePanSliderLimits();

            // Apply current transform (scale/pan) to the resized canvas and redraw
            updateCanvasTransform();
        });

        // Keyboard state tracking
        let pressedKeys = {};
        window.addEventListener("keydown", function (event) {
             // Ignore keydowns if focus is on an input/select/button to allow typing/interaction
             if (['INPUT', 'SELECT', 'BUTTON'].includes(event.target.tagName)) {
                 // Allow +/- for zoom even if zoom buttons have focus? Maybe not for simplicity.
                 return;
             }
             // Ignore if modifier keys are the primary press (e.g., holding Shift)
             if (event.key === 'Shift' || event.key === 'Control' || event.key === 'Alt' || event.key === 'Meta') {
                 return;
             }

            const key = event.key.toLowerCase(); // Normalize key
            if (!pressedKeys[key]) { // Prevent repeated triggers for held keys if handled by single press
                pressedKeys[key] = true;
                handleKeyPresses(event, true); // Pass event and indicate it's a down press
            }
            // Prevent default browser actions for keys we handle (like arrows scrolling)
            if (['arrowup', 'arrowdown', 'arrowleft', 'arrowright', '+', '-', '=', '_', 'm', 'r', 'c'].includes(key)) {
                event.preventDefault();
            }
        });

        window.addEventListener("keyup", function (event) {
             const key = event.key.toLowerCase();
             delete pressedKeys[key];
             // Optionally handle key up actions if needed
             // handleKeyPresses(event, false);
        });

        // Handles both single key presses and continuous actions based on pressedKeys
        function handleKeyPresses(event, isKeyDown) {
            // Panning speed adjusted by zoom level for consistent perceived movement
            const panStep = 15 / scale;
            // Rotation speed uses the velocity slider value
            const angleStep = rotationVelocity;
            let needsRedraw = false; // Track if redraw is needed by key actions
            let transformChanged = false; // Track if pan/zoom requires transform update

            const key = event.key.toLowerCase();

             // --- Continuous Actions (checked directly via pressedKeys) ---
             // These run as long as the key is held down (handled by browser repeat or animation loop)
             // We check `pressedKeys` directly here.

             if (pressedKeys["a"] || pressedKeys["arrowleft"]) { // Rotate left/CCW
                if (mode === "pendulum") pendulumAngle -= angleStep; else startAngle -= angleStep;
                needsRedraw = true;
             }
             if (pressedKeys["d"] || pressedKeys["arrowright"]) { // Rotate right/CW
                 if (mode === "pendulum") pendulumAngle += angleStep; else startAngle += angleStep;
                 needsRedraw = true;
             }
             if (pressedKeys["w"] || pressedKeys["arrowup"]) { // Pan Up (positive Y offset)
                 originY += panStep; transformChanged = true;
             }
             if (pressedKeys["s"] || pressedKeys["arrowdown"]) { // Pan Down (negative Y offset)
                 originY -= panStep; transformChanged = true;
             }
             if (pressedKeys["q"]) { // Pan Left (positive X offset) - Less common binding
                 originX += panStep; transformChanged = true;
             }
             if (pressedKeys["e"]) { // Pan Right (negative X offset) - Less common binding
                 originX -= panStep; transformChanged = true;
             }

             // --- Single Press Actions (only trigger on keydown) ---
             if (isKeyDown) {
                 if (key === "m") { // Toggle Mode
                    const modes = ['many', 'single', 'pendulum', 'anaglyph'];
                    const currentModeIndex = modes.indexOf(mode);
                    const nextModeIndex = (currentModeIndex + 1) % modes.length;
                    // Trigger change via the select element to sync UI and logic
                    const modeSelect = document.getElementById('visualization-mode');
                    modeSelect.value = modes[nextModeIndex];
                    modeSelect.dispatchEvent(new Event('input', { bubbles: true }));
                    // Redraw is handled by the 'input' event listener
                    needsRedraw = false;
                    transformChanged = false;
                }
                 if (key === "r") { // Reset View (Zoom and Pan)
                     scale = 1.0;
                     originX = 0;
                     originY = 0;
                     transformChanged = true; // Will update sliders and redraw
                     needsRedraw = false;
                 }
                 // Reset Center Offset (C) - Not applicable now pan is separate
                 // if (key === "c") { ... }

                if (key === "=" || key === "+") { // Zoom In
                     zoom(1 / zoomFactor, canvasWidth / 2, canvasHeight / 2); // Zoom towards center
                     transformChanged = false; // zoom() calls updateCanvasTransform()
                     needsRedraw = false;
                 }
                 if (key === "-" || key === "_") { // Zoom Out
                     zoom(zoomFactor, canvasWidth / 2, canvasHeight / 2); // Zoom out from center
                     transformChanged = false;
                     needsRedraw = false;
                 }
             }

            // --- Update UI & LocalStorage for changed state ---
            if (transformChanged) {
                // Clamp origin to slider limits before updating UI
                const minH = parseFloat(horizontalOffsetSlider.min);
                const maxH = parseFloat(horizontalOffsetSlider.max);
                const minV = parseFloat(verticalOffsetSlider.min);
                const maxV = parseFloat(verticalOffsetSlider.max);
                originX = Math.max(minH, Math.min(originX, maxH));
                originY = Math.max(minV, Math.min(originY, maxV));

                // Update sliders to reflect new pan position
                horizontalOffsetSlider.value = originX;
                verticalOffsetSlider.value = originY;
                // Save the new pan position
                setLocalStorageValue('originX', originX);
                setLocalStorageValue('originY', originY);
                // Apply the transform and redraw
                updateCanvasTransform();
            }

            // Save angles (could throttle this if performance is an issue)
            if (needsRedraw && (pressedKeys["a"] || pressedKeys["d"] || pressedKeys["arrowleft"] || pressedKeys["arrowright"])) {
                 if (mode === "pendulum") {
                     setLocalStorageValue('pendulumAngle', pendulumAngle);
                 } else {
                     setLocalStorageValue('startAngle', startAngle);
                 }
             }

            // Request redraw if needed and not handled by transform update or autopilot
            if (needsRedraw && !transformChanged && !shouldAnimate) {
                requestAnimationFrame(draw);
            }
        }


        // --- Zoom and Pan Implementation ---

        /**
         * Initializes zoom and pan event listeners (mouse and touch).
         */
        function initializeZoomAndPan() {
            const zoomInButton = document.getElementById('zoom-in');
            const zoomOutButton = document.getElementById('zoom-out');

            // Zoom button clicks
            zoomInButton.addEventListener('click', () => zoom(1 / zoomFactor, canvasWidth / 2, canvasHeight / 2));
            zoomOutButton.addEventListener('click', () => zoom(zoomFactor, canvasWidth / 2, canvasHeight / 2));

            // Mouse Wheel Zooming
            canvas.addEventListener('wheel', function (event) {
                event.preventDefault(); // Prevent page scrolling
                const delta = event.deltaY > 0 ? zoomFactor : 1 / zoomFactor; // Determine zoom direction
                const rect = canvas.getBoundingClientRect();
                // Calculate mouse position relative to the canvas
                const mouseX = event.clientX - rect.left;
                const mouseY = event.clientY - rect.top;
                // Zoom towards the mouse cursor position
                zoom(delta, mouseX, mouseY);
            });

            // --- Touch Events for Mobile Pan and Pinch Zoom ---
            canvas.addEventListener('touchstart', (event) => {
                 // Prevent default touch actions like scrolling or double-tap zoom
                 // Be cautious if you need default actions elsewhere on the page
                 // event.preventDefault();

                if (event.touches.length === 1) {
                    // --- Single Touch: Start Panning ---
                    isDragging = true;
                    isPinching = false; // Ensure not pinching
                    const touch = event.touches[0];
                    // Record starting touch position and current pan origin
                    lastX = touch.clientX;
                    lastY = touch.clientY;
                    // No need to store startOriginX/Y, pan is relative to last position
                    canvas.style.cursor = 'grabbing'; // Visual feedback

                } else if (event.touches.length === 2) {
                    // --- Two Touches: Start Pinch Zoom ---
                    isDragging = false; // Stop panning if two fingers down
                    isPinching = true;
                    event.preventDefault(); // Prevent default pinch actions (like page zoom)
                    const touch1 = event.touches[0];
                    const touch2 = event.touches[1];
                    // Calculate initial distance between fingers
                    pinchStartDistance = Math.hypot(touch1.clientX - touch2.clientX, touch1.clientY - touch2.clientY);
                }
            }, { passive: false }); // Need passive: false to preventDefault reliably

            canvas.addEventListener('touchmove', (event) => {
                // Always prevent default during touch move on canvas to avoid scrolling interference
                 event.preventDefault();

                if (event.touches.length === 1 && isDragging) {
                    // --- Single Touch Move: Panning ---
                    const touch = event.touches[0];
                    // Calculate change in position since last move event
                    const dx = touch.clientX - lastX;
                    const dy = touch.clientY - lastY;

                    // Update pan origin (add delta to current origin)
                    originX += dx;
                    originY += dy;

                    // Update last position for the next move event
                    lastX = touch.clientX;
                    lastY = touch.clientY;

                    // Update sliders and apply transform
                    updatePanFromInteraction(); // Helper to update sliders/storage/transform


                } else if (event.touches.length === 2 && isPinching) {
                    // --- Two Touches Move: Pinch Zoom ---
                    const touch1 = event.touches[0];
                    const touch2 = event.touches[1];
                    // Calculate current distance and pinch center
                    const currentDistance = Math.hypot(touch1.clientX - touch2.clientX, touch1.clientY - touch2.clientY);
                    const rect = canvas.getBoundingClientRect();
                    const pinchCenterX = ((touch1.clientX + touch2.clientX) / 2) - rect.left;
                    const pinchCenterY = ((touch1.clientY + touch2.clientY) / 2) - rect.top;

                    // Calculate zoom delta (inverse relationship: smaller distance -> zoom in -> delta < 1)
                    if (pinchStartDistance > 0) { // Avoid division by zero
                         const delta = pinchStartDistance / currentDistance;
                         zoom(delta, pinchCenterX, pinchCenterY); // Zoom towards the pinch center
                    }

                    // Update start distance for continuous zoom
                    pinchStartDistance = currentDistance;
                }
            }, { passive: false }); // Need passive: false to preventDefault

            canvas.addEventListener('touchend', (event) => {
                 // If less than 2 fingers, stop pinching
                 if (event.touches.length < 2) {
                     isPinching = false;
                     pinchStartDistance = 0;
                 }
                 // If no fingers left, stop dragging/panning
                 if (event.touches.length < 1) {
                     isDragging = false;
                     canvas.style.cursor = 'grab'; // Reset cursor
                 }
             });

             // Handle cases where touch is cancelled (e.g., moving off screen)
             canvas.addEventListener('touchcancel', (event) => {
                 isDragging = false;
                 isPinching = false;
                 pinchStartDistance = 0;
                 canvas.style.cursor = 'grab';
             });


            // --- Mouse Drag Panning ---
            canvas.addEventListener('mousedown', function (event) {
                 if (event.button !== 0) return; // Only pan with left mouse button
                 // Prevent starting drag if interacting with controls that might overlay canvas edge
                if (event.target !== canvas) return;

                isDragging = true;
                isPinching = false; // Ensure not pinching
                // Record starting mouse position and current pan origin
                lastX = event.clientX;
                lastY = event.clientY;
                canvas.style.cursor = 'grabbing'; // Indicate panning action
                event.preventDefault(); // Prevent text selection during drag
            });

            canvas.addEventListener('mousemove', function (event) {
                if (isDragging) {
                    // Calculate change in position
                    const dx = event.clientX - lastX;
                    const dy = event.clientY - lastY;

                    // Update pan origin
                    originX += dx;
                    originY += dy;

                    // Update last position
                    lastX = event.clientX;
                    lastY = event.clientY;

                    // Update sliders and apply transform
                    updatePanFromInteraction();
                }
            });

            // Stop panning on mouse up anywhere
            window.addEventListener('mouseup', function (event) {
                 if (event.button === 0 && isDragging) {
                    isDragging = false;
                    canvas.style.cursor = 'grab'; // Reset cursor
                 }
            });

            // Stop panning if mouse leaves the canvas *while dragging*
            canvas.addEventListener('mouseleave', function (event) {
                if (isDragging) {
                    // Optional: Decide if you want dragging to continue even if mouse leaves canvas temporarily
                    // If yes, remove this block. If no (stop when leaving canvas), keep it.
                    isDragging = false;
                    canvas.style.cursor = 'grab';
                }
            });

             // Set initial cursor state
            canvas.style.cursor = 'grab';
        }

        /**
         * Helper function called after interactive panning (mouse/touch drag).
         * Updates sliders, clamps origin, saves to LS, and applies transform.
         */
        function updatePanFromInteraction() {
            // Clamp origin values to the pan slider's min/max range
            const minH = parseFloat(horizontalOffsetSlider.min);
            const maxH = parseFloat(horizontalOffsetSlider.max);
            const minV = parseFloat(verticalOffsetSlider.min);
            const maxV = parseFloat(verticalOffsetSlider.max);
            originX = Math.max(minH, Math.min(originX, maxH));
            originY = Math.max(minV, Math.min(originY, maxV));

            // Update the slider positions to reflect the new pan origin
            horizontalOffsetSlider.value = originX;
            verticalOffsetSlider.value = originY;

            // Save the updated origin to localStorage
            setLocalStorageValue('originX', originX);
            setLocalStorageValue('originY', originY);

            // Apply the new transform to the canvas and redraw
            updateCanvasTransform();
        }

        /**
         * Applies zoom transformation centered around a specific point.
         * @param {number} delta - The zoom factor (e.g., 1.1 for zoom out, 1/1.1 for zoom in).
         * @param {number} pointX - The X coordinate of the zoom center (relative to canvas).
         * @param {number} pointY - The Y coordinate of the zoom center (relative to canvas).
         */
       function zoom(delta, pointX, pointY) {
            const newScale = Math.max(minScale, Math.min(scale * delta, maxScale)); // Apply zoom limits
            // Calculate how much the scale actually changed (might be clamped)
            const scaleChange = newScale / scale;

            // Adjust originX/Y so the point (pointX, pointY) remains fixed *relative* to the viewport
            // Formula: newOrigin = point - (point - oldOrigin) * scaleChangeRatio
            originX = pointX - (pointX - originX) * scaleChange;
            originY = pointY - (pointY - originY) * scaleChange;

            scale = newScale; // Update the global scale

            // Update pan sliders to reflect potential origin change due to zoom pivot
            updatePanFromInteraction(); // This also calls updateCanvasTransform
            // setLocalStorageValue('scale', scale); // Optionally save scale
        }


        /**
         * Applies the current scale and origin translation to the canvas context
         * and requests a redraw.
         */
        function updateCanvasTransform() {
            // Apply the combined scale and translation transform
             context.setTransform(scale, 0, 0, scale, originX, originY);

            // Request redraw. If animating, the animation loop handles drawing.
            // If not animating, request a single frame draw.
            if (!shouldAnimate) {
                 requestAnimationFrame(draw);
            }
        }

        // --- Drawing Functions ---

        // Helper to get the logical center X (ignoring pan, as pan is in transform)
        function getLogicalCenterX() { return canvasWidth / 2; }
        // Helper to get the logical center Y
        function getLogicalCenterY() { return canvasHeight / 2; }


        /**
         * Draws the visualization in "Pendulum" mode.
         */
        function drawPendulum() {
            const centerX = getLogicalCenterX(); // Draw relative to logical center
            const centerY = getLogicalCenterY();
            const currentRadius = radius * 1.7 + arcOffset; // Effective radius of the circle outline

            // Draw main circle outline (adapts thickness/dash to zoom)
            context.strokeStyle = color3;
            context.lineWidth = Math.max(1, 4 / scale); // Keep outline somewhat consistent
            context.setLineDash([circleOutlineDashDensity / scale, circleOutlineDashDensity / scale]);
            context.beginPath();
            context.arc(centerX, centerY, currentRadius, 0, 2 * Math.PI);
            context.stroke();
            context.setLineDash([]); // Reset line dash

            // Calculate pendulum position
            const normalizedPendulumAngle = ((pendulumAngle % 360) + 360) % 360; // Ensure 0-360
            const angleRad = normalizedPendulumAngle * Math.PI / 180;
            const orbitRadius = radius * lineLength; // Use main radius and length factor

            const pendulumX = centerX + orbitRadius * Math.cos(angleRad);
            const pendulumY = centerY + orbitRadius * Math.sin(angleRad);

            // Draw line from center to pendulum (adapts thickness to zoom)
            context.beginPath();
            context.strokeStyle = color; // Line color
            context.lineWidth = Math.max(1, lineThickness / scale);
            context.moveTo(centerX, centerY);
            context.lineTo(pendulumX, pendulumY);
            context.stroke();

            // Draw pendulum circle (bob) - size does not scale aggressively
            context.beginPath();
            context.fillStyle = color2; // Pendulum bob color
            const bobRadius = Math.max(2, pendulumThickness / 2); // Keep bob size relatively constant on screen
            context.arc(pendulumX, pendulumY, bobRadius, 0, 2 * Math.PI);
            context.fill();

            // Draw angle text (font size remains constant on screen)
            const textDist = radius * textDistance;
            const textX = centerX + textDist * Math.cos(angleRad);
            const textY = centerY + textDist * Math.sin(angleRad);

            context.font = `${textSize}px Verdana`; // Use fixed pixel size
            context.textAlign = "center";
            context.textBaseline = "middle";
            context.fillStyle = textColor;

            context.save(); // Save context for potential text rotation/translation
            context.translate(textX, textY);
            // Optional: Rotate text radially context.rotate(angleRad + Math.PI / 2);
            context.fillText(angleName(normalizedPendulumAngle), 0, 0); // Draw at new (0,0)
            context.restore(); // Restore previous context state
        }

        /**
         * Draws the visualization in "Many Lines" mode. (CORRECTED)
         */
         function drawManyLines() {
            const centerX = getLogicalCenterX();
            const centerY = getLogicalCenterY();
            const currentRadius = radius * 1.7 + arcOffset;

            // Draw circle outline (adapts thickness/dash to zoom)
            context.strokeStyle = color3;
            context.lineWidth = Math.max(1, 4 / scale);
            context.setLineDash([circleOutlineDashDensity / scale, circleOutlineDashDensity / scale]);
            context.beginPath();
            context.arc(centerX, centerY, currentRadius, 0, 2 * Math.PI);
            context.stroke();
            context.setLineDash([]);

            // Text properties (font size fixed on screen)
            context.font = `${textSize}px Verdana`;
            context.textAlign = "center";
            context.textBaseline = "middle";

            // Line properties
            const lineStartDistance = radius * 0.0; // Start lines from center
            const lineEndDistance = radius * lineLength;
            const textDist = radius * textDistance;
            const numLines = parseInt(radiatingLineCount);
             if (numLines < 1) return; // Need at least 1 line
             const angleIncrement = (numLines > 1) ? (360 / numLines) : 0; // Avoid division by zero if numLines is 1
             const currentLineThickness = Math.max(1, lineThickness / scale); // Scale thickness

             // Determine the index of the line opposite the first one (index 0)
             // This only makes sense if the number of lines is even.
             const oppositeIndex = (numLines > 1 && numLines % 2 === 0) ? (numLines / 2) : -1; // Use -1 if no direct opposite

            for (let i = 0; i < numLines; i++) {
                 let angleDeg = (i * angleIncrement + startAngle);
                 let normalizedAngleDeg = ((angleDeg % 360) + 360) % 360; // Normalize 0-360
                 let angleRad = normalizedAngleDeg * Math.PI / 180;

                 // Calculate line points relative to logical center
                 let startX = centerX + lineStartDistance * Math.cos(angleRad);
                 let startY = centerY + lineStartDistance * Math.sin(angleRad);
                 let endX = centerX + lineEndDistance * Math.cos(angleRad);
                 let endY = centerY + lineEndDistance * Math.sin(angleRad);

                 // --- Color Logic ---
                 // Assign the special color (color2) to the first line (index 0)
                 // AND to its opposite line, but only if numLines is even.
                 const isDesignatedSpecialLine = (i === 0) || (oppositeIndex !== -1 && i === oppositeIndex);
                 context.strokeStyle = isDesignatedSpecialLine ? color2 : color;
                 // --- End Color Logic ---

                 // Draw the line
                 context.lineWidth = currentLineThickness;
                 context.beginPath();
                 context.moveTo(startX, startY);
                 context.lineTo(endX, endY);
                 context.stroke();

                 // Calculate and draw text
                 let textX = centerX + textDist * Math.cos(angleRad);
                 let textY = centerY + textDist * Math.sin(angleRad);
                 context.fillStyle = textColor;
                 context.save();
                 context.translate(textX, textY);
                 // Optional: context.rotate(angleRad + Math.PI / 2);
                 context.fillText(angleName(normalizedAngleDeg), 0, 0);
                 context.restore();
            }
        }

        /**
         * Draws the visualization in "Single Line" mode.
         */
        function drawSingleLine() {
            const centerX = getLogicalCenterX();
            const centerY = getLogicalCenterY();
            const currentRadius = radius * 1.7 + arcOffset;

            // Draw circle outline
            context.strokeStyle = color3;
            context.lineWidth = Math.max(1, 4 / scale);
            context.setLineDash([circleOutlineDashDensity / scale, circleOutlineDashDensity / scale]);
            context.beginPath();
            context.arc(centerX, centerY, currentRadius, 0, 2 * Math.PI);
            context.stroke();
            context.setLineDash([]);

            // Text properties
            context.font = `${textSize}px Verdana`;
            context.textAlign = "center";
            context.textBaseline = "middle";

            // Calculate angle and line properties
            let normalizedAngleDeg = ((startAngle % 360) + 360) % 360;
            let angleRad = normalizedAngleDeg * Math.PI / 180;
            const lineStartDistance = radius * 0.0;
            const lineEndDistance = radius * lineLength;
            const textDist = radius * textDistance;
            const currentLineThickness = Math.max(1, lineThickness / scale);

            // Calculate coordinates relative to logical center
            let startX = centerX + lineStartDistance * Math.cos(angleRad);
            let startY = centerY + lineStartDistance * Math.sin(angleRad);
            let endX = centerX + lineEndDistance * Math.cos(angleRad);
            let endY = centerY + lineEndDistance * Math.sin(angleRad);
            let textX = centerX + textDist * Math.cos(angleRad);
            let textY = centerY + textDist * Math.sin(angleRad);

            // Draw the single line using color2
            context.lineWidth = currentLineThickness;
            context.strokeStyle = color2; // Use color2 (designated "special" color)
            context.beginPath();
            context.moveTo(startX, startY);
            context.lineTo(endX, endY);
            context.stroke();

             // Draw the text
            context.fillStyle = textColor;
             context.save();
             context.translate(textX, textY);
             // Optional: context.rotate(angleRad + Math.PI / 2);
             context.fillText(angleName(normalizedAngleDeg), 0, 0);
             context.restore();
        }


        /**
         * Draws the visualization in "Anaglyph 3D" mode.
         * Renders separate views for the left (red) and right (cyan) eyes, offset horizontally.
         */
        function drawAnaglyph() {
            const centerX = getLogicalCenterX();
            const centerY = getLogicalCenterY();
            const currentRadius = radius * 1.7 + arcOffset;
            // Calculate pixel offset for depth based on slider, radius, and zoom
            // More depth effect when zoomed out, less when zoomed in.
            const baseDepthPixelOffset = (depthOffset / 2) * (radius * 0.01) / Math.sqrt(scale) ;

            // --- Draw Circle Outline (Once, neutrally or averaged) ---
            // Draw using the standard outline color for simplicity.
            context.strokeStyle = color3;
            context.lineWidth = Math.max(1, 4 / scale);
            context.setLineDash([circleOutlineDashDensity / scale, circleOutlineDashDensity / scale]);
            context.beginPath();
            context.arc(centerX, centerY, currentRadius, 0, 2 * Math.PI);
            context.stroke();
            context.setLineDash([]);


            // Common properties
            context.font = `${textSize}px Verdana`;
            context.textAlign = "center";
            context.textBaseline = "middle";
            const lineStartDistance = radius * 0.0;
            const lineEndDistance = radius * lineLength;
            const textDist = radius * textDistance;
            const numLines = parseInt(radiatingLineCount);
             if (numLines < 1) return;
             const angleIncrement = numLines === 1 ? 0 : 360 / numLines;
             const currentLineThickness = Math.max(1, lineThickness / scale);

            // --- Draw Left Eye View (Red Filter) ---
            context.strokeStyle = anaglyphLeftColor;
            context.fillStyle = anaglyphLeftColor;
            context.lineWidth = currentLineThickness;
            const leftShift = -baseDepthPixelOffset; // Shift left

            for (let i = 0; i < numLines; i++) {
                let angleDeg = (i * angleIncrement + startAngle);
                 let normalizedAngleDeg = ((angleDeg % 360) + 360) % 360;
                 let angleRad = normalizedAngleDeg * Math.PI / 180;

                 // Calculate points shifted horizontally for left eye
                 let lStartX = centerX + lineStartDistance * Math.cos(angleRad) + leftShift; // Use different var names
                 let lStartY = centerY + lineStartDistance * Math.sin(angleRad); // No vertical shift in basic anaglyph
                 let lEndX = centerX + lineEndDistance * Math.cos(angleRad) + leftShift;
                 let lEndY = centerY + lineEndDistance * Math.sin(angleRad);
                 let lTextX = centerX + textDist * Math.cos(angleRad) + leftShift;
                 let lTextY = centerY + textDist * Math.sin(angleRad);

                // Draw line
                context.beginPath(); context.moveTo(lStartX, lStartY); context.lineTo(lEndX, lEndY); context.stroke();
                // Draw text
                 context.save(); context.translate(lTextX, lTextY); context.fillText(angleName(normalizedAngleDeg), 0, 0); context.restore();
            }


            // --- Draw Right Eye View (Cyan Filter) ---
            context.strokeStyle = anaglyphRightColor;
            context.fillStyle = anaglyphRightColor;
            // lineWidth is already set
            const rightShift = baseDepthPixelOffset; // Shift right

            for (let i = 0; i < numLines; i++) {
                 let angleDeg = (i * angleIncrement + startAngle);
                 let normalizedAngleDeg = ((angleDeg % 360) + 360) % 360;
                 let angleRad = normalizedAngleDeg * Math.PI / 180;

                 // Calculate points shifted horizontally for right eye
                 let rStartX = centerX + lineStartDistance * Math.cos(angleRad) + rightShift; // Use different var names
                 let rStartY = centerY + lineStartDistance * Math.sin(angleRad);
                 let rEndX = centerX + lineEndDistance * Math.cos(angleRad) + rightShift;
                 let rEndY = centerY + lineEndDistance * Math.sin(angleRad);
                 let rTextX = centerX + textDist * Math.cos(angleRad) + rightShift;
                 let rTextY = centerY + textDist * Math.sin(angleRad);

                // Draw line
                context.beginPath(); context.moveTo(rStartX, rStartY); context.lineTo(rEndX, rEndY); context.stroke();
                // Draw text
                context.save(); context.translate(rTextX, rTextY); context.fillText(angleName(normalizedAngleDeg), 0, 0); context.restore();
            }
        }


        // --- Main Draw Function ---
        /**
         * Clears the canvas respecting the current transform (zoom/pan)
         * and calls the appropriate mode-specific drawing function.
         */
        function draw() {
            context.save(); // Save the current zoomed/panned transform state
            // Temporarily reset transform to identity (un-zoomed, un-panned)
            context.setTransform(1, 0, 0, 1, 0, 0);
            // Clear the entire underlying canvas bitmap with the background color
            context.fillStyle = bgColor;
            context.fillRect(0, 0, canvasWidth, canvasHeight);
            context.restore(); // Restore the zoom/pan transform for drawing

            // Call the drawing function for the current mode
            if (mode === "many") drawManyLines();
            else if (mode === "single") drawSingleLine();
            else if (mode === "pendulum") drawPendulum();
            else if (mode === "anaglyph") drawAnaglyph();

            // DEBUG: Draw origin crosshair if needed
            /*
            context.save();
            context.setTransform(1, 0, 0, 1, 0, 0); // Use identity transform
            context.strokeStyle = 'lime'; context.lineWidth = 1; context.beginPath();
            context.moveTo(originX - 10, originY); context.lineTo(originX + 10, originY);
            context.moveTo(originX, originY - 10); context.lineTo(originX, originY + 10);
            context.stroke(); context.restore();
            */
        }


        // --- Animation and Autopilot Logic ---

        let animationFrameId = null;    // ID returned by requestAnimationFrame
        let shouldAnimate = false;      // Flag to control the animation loop
        let autopilot1Active = false;   // Is Autopilot 1 (random jump) running?
        let autopilot2Active = false;   // Is Autopilot 2 (smooth transition) running?
        let autopilotCenterShiftTimeout = null; // Timeout ID for AP1 jumps/AP2 start delay
        let rotationDirection = rotateClockwise ? 1 : -1; // -1 for CCW, 1 for CW

        // State for Autopilot 2 smooth transitions
        let isTransitioning = false;    // Is a smooth pan transition in progress?
        let transitionStartTime = 0;    // Timestamp when the current transition started
        let transitionDuration = 1000;  // Duration of the transition (calculated based on speed)
        let transitionStartX = 0;       // Starting originX for the transition
        let transitionStartY = 0;       // Starting originY for the transition
        let targetOriginX = originX;    // Target originX for the transition
        let targetOriginY = originY;    // Target originY for the transition


        /**
         * The main animation loop, requested via requestAnimationFrame.
         * Updates angles, handles smooth transitions, and redraws the scene.
         * @param {DOMHighResTimeStamp} timestamp - The timestamp provided by requestAnimationFrame.
         */
        function animate(timestamp) {
            if (!shouldAnimate) {
                 animationFrameId = null; // Ensure ID is cleared when stopping
                 return; // Exit the loop
            }

            // 1. Update Animated State
            updateAnglesForAnimation(); // Update rotation based on velocity/direction

            if (autopilot2Active && isTransitioning) {
                 updateTransition(timestamp); // Update smooth pan position if active
            }

            // 2. Draw the updated scene
            draw();

            // 3. Request the next frame
            animationFrameId = requestAnimationFrame(animate);
        }

        /**
         * Updates the startAngle or pendulumAngle based on rotationVelocity and direction.
         * Called within the animation loop.
         */
        function updateAnglesForAnimation() {
            const effectiveRotationVelocity = rotationVelocity * rotationDirection;
             if (mode === "pendulum") {
                 pendulumAngle += effectiveRotationVelocity;
                 // Don't save to LS on every frame, maybe only when autopilot stops or user interacts?
                 // setLocalStorageValue('pendulumAngle', pendulumAngle);
             } else { // Many, Single, Anaglyph modes
                 startAngle += effectiveRotationVelocity;
                 // setLocalStorageValue('startAngle', startAngle);
             }
        }

        // --- Dark Mode ---
        /**
         * Applies or removes dark mode CSS classes to relevant elements.
         * @param {boolean} isDark - True to apply dark mode, false for light mode.
         */
        function applyDarkMode(isDark) {
            const darkModeIcon = toggleDarkModeButton.querySelector('i');
            const action = isDark ? 'add' : 'remove'; // Method to call on classList

            document.body.classList[action]('dark-mode-body');
            controlsContainer.classList[action]('dark-mode'); // Apply to container too
            controls.classList[action]('dark-mode');
            toggleMenuButton.classList[action]('dark-mode');
            // Apply to zoom buttons
             for (let button of document.getElementById('zoom-controls').children) {
                 button.classList[action]('dark-mode');
             }
            // Apply to Autopilot buttons explicitly if needed (should inherit via #controls.dark-mode)
            // toggleAutopilot1Button.classList[action]('dark-mode');
            // toggleAutopilot2Button.classList[action]('dark-mode');

            // Update icon and title
            if (isDark) {
                darkModeIcon.classList.remove('fa-sun'); darkModeIcon.classList.add('fa-moon');
                toggleDarkModeButton.title = "Switch to Light Mode";
            } else {
                darkModeIcon.classList.remove('fa-moon'); darkModeIcon.classList.add('fa-sun');
                toggleDarkModeButton.title = "Switch to Dark Mode";
            }
        }

        // Dark Mode Toggle Button Listener
        toggleDarkModeButton.addEventListener('click', () => {
            isDarkMode = !isDarkMode;
            setLocalStorageValue('isDarkMode', isDarkMode);
            applyDarkMode(isDarkMode);
        });

        // --- Autopilot Control Functions ---

        // Rotation Direction Checkbox Listeners
        rotateClockwiseToggle.addEventListener('change', () => {
            if (rotateClockwiseToggle.checked) {
                 rotationDirection = 1;
                 rotateCounterClockwiseToggle.checked = false; // Ensure mutual exclusivity
                 setLocalStorageValue('rotateClockwise', 'true');
                 setLocalStorageValue('rotateCounterclockwise', 'false');
            } else if (!rotateCounterClockwiseToggle.checked) {
                 rotateClockwiseToggle.checked = true; // Prevent unchecking both
            }
        });
        rotateCounterClockwiseToggle.addEventListener('change', () => {
             if (rotateCounterClockwiseToggle.checked) {
                 rotationDirection = -1;
                 rotateClockwiseToggle.checked = false;
                 setLocalStorageValue('rotateClockwise', 'false');
                 setLocalStorageValue('rotateCounterclockwise', 'true');
             } else if (!rotateClockwiseToggle.checked) {
                // Correction: if you uncheck this, re-check the *other* one (clockwise)
                rotateCounterClockwiseToggle.checked = false; // Uncheck self first
                rotateClockwiseToggle.checked = true;        // Check the other
                rotationDirection = 1;                      // Update direction
                setLocalStorageValue('rotateClockwise', 'true');
                setLocalStorageValue('rotateCounterclockwise', 'false');
             }
        });

        // Autopilot Speed Slider Listener (restarts autopilot to apply new speed)
        document.getElementById('autopilot-speed').addEventListener('input', function () {
            autopilotSpeed = parseInt(this.value);
            setLocalStorageValue('autopilotSpeed', autopilotSpeed);
             // Restart active autopilot to apply new speed/timing
             if (autopilot1Active) { stopAutopilot1(); startAutopilot1(); }
             else if (autopilot2Active) { stopAutopilot2(); startAutopilot2(); }
        });

        // Autopilot Walk Range Slider Listener
        autopilotWalkRangeSlider.addEventListener('input', function () {
            autopilotWalkRange = parseInt(this.value);
            setLocalStorageValue('autopilotWalkRange', autopilotWalkRange);
            // This range affects the *next* calculated target offset, no immediate visual change.
        });

        /**
         * Updates the placeholder text for the 'special-line-color' label based on the current mode.
         */
        function updateTextPlaceholder() {
            const label = document.getElementById('special-line-color-label');
            const container = label.closest('div'); // Get parent div
            if(!container) return; // Safety check

            if (mode === "pendulum") label.textContent = "Pendulum Color:";
            else if (mode === "single") label.textContent = "Line Color:";
            else if (mode === "many") label.textContent = "Special Line Color:";
            else { label.textContent = "Special Line Color:"; } // Default
            // Ensure container visibility matches label relevance
             container.style.display = (mode === 'pendulum' || mode === 'single' || mode === 'many') ? 'block' : 'none';
        }

        /**
         * Toggles visibility of mode-specific controls in the panel.
         */
        function toggleControlVisibility() {
            // Get references to mode-specific containers
            const lineCountCont = document.getElementById('radiating-line-count-container');
            const lineColorCont = document.getElementById('line-color-container');
            // Special color is handled by updateTextPlaceholder's container logic
            const pendulumSizeCont = document.getElementById('pendulum-size-container');
            const anaglyphPickers = document.getElementById('anaglyph-color-pickers');
            const depthOffsetCont = document.getElementById('depth-offset-container');

            // Hide all first
            lineCountCont.style.display = 'none';
            lineColorCont.style.display = 'none';
            pendulumSizeCont.style.display = 'none';
            anaglyphPickers.style.display = 'none';
            depthOffsetCont.style.display = 'none';

            // Show based on current mode
            if (mode === 'many') {
                lineCountCont.style.display = 'block';
                lineColorCont.style.display = 'block'; // Show regular line color
            } else if (mode === 'single') {
                // No line count, no regular color needed
            } else if (mode === 'pendulum') {
                lineColorCont.style.display = 'block'; // For the connecting line
                pendulumSizeCont.style.display = 'block';
            } else if (mode === 'anaglyph') {
                lineCountCont.style.display = 'block';
                anaglyphPickers.style.display = 'block';
                depthOffsetCont.style.display = 'block';
            }
            // Call this AFTER setting display none/block for other containers
            updateTextPlaceholder(); // Ensures special color label/container hides/shows correctly
        }


        // --- Autopilot 1: Random Jump ---
        toggleAutopilot1Button.addEventListener('click', () => {
            if (!autopilot1Active) startAutopilot1(); else stopAutopilot1();
        });

        function startAutopilot1() {
            if (autopilot2Active) stopAutopilot2(); // Ensure mutually exclusive

            autopilot1Active = true;
            toggleAutopilot1Button.textContent = 'Stop Autopilot 1';
            toggleAutopilot1Button.classList.add('active');
            toggleAutopilot2Button.textContent = 'Start Autopilot 2'; // Reset other button
            toggleAutopilot2Button.classList.remove('active');

            horizontalOffsetSlider.disabled = true; // Disable manual pan
            verticalOffsetSlider.disabled = true;

            scheduleNextJump_AP1(); // Start the jump sequence

             // Start animation loop if not already running
             shouldAnimate = true;
             if (!animationFrameId) {
                 animationFrameId = requestAnimationFrame(animate);
             }
        }

        function stopAutopilot1() {
            autopilot1Active = false;
            toggleAutopilot1Button.textContent = 'Start Autopilot 1';
            toggleAutopilot1Button.classList.remove('active');

            clearTimeout(autopilotCenterShiftTimeout); // Stop scheduled jump
            autopilotCenterShiftTimeout = null;

            horizontalOffsetSlider.disabled = false; // Re-enable manual pan
            verticalOffsetSlider.disabled = false;

             // Stop animation loop ONLY if AP2 is also inactive
             if (!autopilot2Active) { shouldAnimate = false; }
        }

        // Schedules the next jump for Autopilot 1
        function scheduleNextJump_AP1() {
             if (!autopilot1Active) return; // Stop if deactivated between schedule and execution

             // Calculate delay based on speed (faster speed -> shorter delay)
             const baseDelay = 5000, minDelay = 500;
             const speedRange = 40 - 5, delayRange = baseDelay - minDelay;
             const delay = baseDelay - ((autopilotSpeed - 5) / speedRange) * delayRange;

             autopilotCenterShiftTimeout = setTimeout(() => {
                 if (!autopilot1Active) return; // Check again before jumping

                 const target = calculateAutopilotTargetOrigin(); // Get target pan values
                 originX = target.x; // Jump instantly
                 originY = target.y;

                 // Update UI Sliders and save state
                 updatePanFromInteraction(); // Updates sliders, saves LS, applies transform

                 scheduleNextJump_AP1(); // Schedule the *next* jump
             }, delay);
         }


        // --- Autopilot 2: Smooth Transition ---
        toggleAutopilot2Button.addEventListener('click', () => {
            if (!autopilot2Active) startAutopilot2(); else stopAutopilot2();
        });

        function startAutopilot2() {
             if (autopilot1Active) stopAutopilot1(); // Ensure mutually exclusive

            autopilot2Active = true;
            toggleAutopilot2Button.textContent = 'Stop Autopilot 2';
            toggleAutopilot2Button.classList.add('active');
            toggleAutopilot1Button.textContent = 'Start Autopilot 1';
            toggleAutopilot1Button.classList.remove('active');

            horizontalOffsetSlider.disabled = true;
            verticalOffsetSlider.disabled = true;

            startNewTransition_AP2(); // Start the first transition

             shouldAnimate = true;
             if (!animationFrameId) {
                  animationFrameId = requestAnimationFrame(animate);
             }
        }

        function stopAutopilot2() {
             autopilot2Active = false;
             isTransitioning = false; // Stop any ongoing transition calculation
             toggleAutopilot2Button.textContent = 'Start Autopilot 2';
             toggleAutopilot2Button.classList.remove('active');

             horizontalOffsetSlider.disabled = false;
             verticalOffsetSlider.disabled = false;

             if (!autopilot1Active) { shouldAnimate = false; }
        }

        // Starts a new smooth transition for Autopilot 2
        function startNewTransition_AP2() {
            if (!autopilot2Active) return;

            const target = calculateAutopilotTargetOrigin(); // Get target pan
            targetOriginX = target.x;
            targetOriginY = target.y;

            transitionStartX = originX; // Start from current pan position
            transitionStartY = originY;
            transitionStartTime = performance.now(); // Record start time

            // Calculate duration based on speed (faster speed -> shorter duration)
            const baseDuration = 4000, minDuration = 500;
            const speedRange = 40 - 5, durationRange = baseDuration - minDuration;
            transitionDuration = baseDuration - ((autopilotSpeed - 5) / speedRange) * durationRange;

            isTransitioning = true; // Flag that transition is active
            // The animation loop will now call updateTransition()
        }

        /**
         * Calculates the target origin (pan) for autopilot movements based on
         * the autopilotWalkRange setting and current canvas dimensions.
         * @returns {{x: number, y: number}} The target originX and originY.
         */
        function calculateAutopilotTargetOrigin() {
             const walkPercentage = autopilotWalkRange / 100;
             // Calculate max offset relative to the logical center (0,0) of the *panning space*
             const maxHorizontalShift = (canvasWidth / 2) * walkPercentage;
             const maxVerticalShift = (canvasHeight / 2) * walkPercentage;

             // Generate random target within the allowed shift range [-maxShift, +maxShift]
             let targetX = Math.random() * (maxHorizontalShift * 2) - maxHorizontalShift;
             let targetY = Math.random() * (maxVerticalShift * 2) - maxVerticalShift;

            // Clamp target to the absolute limits defined by the pan sliders
            const minH = parseFloat(horizontalOffsetSlider.min);
            const maxH = parseFloat(horizontalOffsetSlider.max);
            const minV = parseFloat(verticalOffsetSlider.min);
            const maxV = parseFloat(verticalOffsetSlider.max);

            targetX = Math.max(minH, Math.min(Math.round(targetX), maxH));
            targetY = Math.max(minV, Math.min(Math.round(targetY), maxV));

            return { x: targetX, y: targetY };
         }

        /**
         * Updates the originX/Y during a smooth Autopilot 2 transition.
         * Called by the animation loop.
         * @param {DOMHighResTimeStamp} currentTime - Timestamp from requestAnimationFrame.
         */
         function updateTransition(currentTime) {
             if (!isTransitioning || !autopilot2Active) {
                 isTransitioning = false;
                 return;
             }

             const elapsedTime = currentTime - transitionStartTime;
             let progress = Math.min(elapsedTime / transitionDuration, 1); // Progress 0 to 1

             // Apply easing for smooth start/end
             const easedProgress = easeInOutCubic(progress);

             // Interpolate origin based on progress
             originX = transitionStartX + (targetOriginX - transitionStartX) * easedProgress;
             originY = transitionStartY + (targetOriginY - transitionStartY) * easedProgress;

             // Update UI Sliders continuously during transition
             horizontalOffsetSlider.value = originX;
             verticalOffsetSlider.value = originY;
             // Avoid spamming localStorage during transition; save only at the end

             // Apply the transform to the canvas so the movement is visible
             updateCanvasTransform(); // <<<<< FIX: Apply transform here

             // Check if transition is complete
             if (progress >= 1) {
                 originX = targetOriginX; // Ensure exact final position
                 originY = targetOriginY;
                 horizontalOffsetSlider.value = originX; // Final UI update
                 verticalOffsetSlider.value = originY;
                 setLocalStorageValue('originX', originX); // Persist final position
                 setLocalStorageValue('originY', originY);

                 isTransitioning = false;

                 // Start the *next* transition immediately for continuous movement
                 if(autopilot2Active) { // Check if still active before starting next
                    startNewTransition_AP2();
                 }
             }
         }

        // --- Easing Function ---
        /**
         * Cubic ease-in-out function.
         * @param {number} t - Progress value (0 to 1).
         * @returns {number} Eased progress value (0 to 1).
         */
        function easeInOutCubic(t) {
            return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
         }

    </script>
</body>

</html>