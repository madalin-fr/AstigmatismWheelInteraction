<!DOCTYPE html>
<html lang="en"> <!-- Added language declaration -->

<head>
    <title>Interactive Astigmatism Wheel: Explore & Visualize Online</title> <!-- Slightly more active title -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"> <!-- Added viewport for mobile -->

    <!-- Basic Metadata -->
    <meta name="author" content="Frincu Madalin">
    <meta name="copyright" content="Â© 2024 Frincu Madalin. All Rights Reserved.">
    <meta name="license" content="http://creativecommons.org/licenses/by-nc-sa/4.0/">
    <meta name="google-site-verification" content="Nq5VPR_L9XqPIXpH4yenmGVKwdxyMAerw6HSiSwSDcA" />

    <!-- SEO Meta Tags - Enhanced -->
    <meta name="description"
        content="Explore astigmatism with this interactive online wheel visualization. Adjust line count, colors, rotation, anaglyph 3D, zoom/pan, and autopilot modes. A web-based tool for learning and visual exploration, not a medical diagnosis."> <!-- Refined description -->
    <meta name="keywords"
        content="astigmatism, astigmatism wheel, interactive visualization, eye chart simulation, ophthalmology tool, vision visualization, visual acuity, refractive error, anaglyph 3D vision, interactive eye simulation, web-based vision tool, online astigmatism explorer, learn about astigmatism, javascript canvas animation, zoom, pan"> <!-- Expanded keywords -->
    <link rel="canonical" href="https://madalin-fr.github.io/AstigmatismWheelInteraction/">
    <meta name="robots" content="index, follow">

    <!-- Open Graph / Social Media Meta Tags -->
    <meta property="og:title" content="Interactive Astigmatism Wheel Visualization">
    <meta property="og:description"
        content="Explore astigmatism visually with adjustable settings like anaglyph 3D, line count, colors, zoom/pan, and autopilot modes. An interactive learning tool."> <!-- Slightly refined OG desc -->
    <meta property="og:image" content="https://madalin-fr.github.io/AstigmatismWheelInteraction/assets/preview-image-3.png">
    <meta property="og:url" content="https://madalin-fr.github.io/AstigmatismWheelInteraction/">
    <meta property="og:type" content="website">
    <meta property="og:site_name" content="Astigmatism Wheel Interactions"> <!-- Added Site Name -->
    <meta property="og:locale" content="en_US"> <!-- Added Locale -->

    <!-- Twitter Card Meta Tags -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Interactive Astigmatism Wheel Visualization">
    <meta name="twitter:description" content="An interactive online tool to visualize and explore the concepts of astigmatism with various customizable settings including zoom and pan."> <!-- Slightly refined Twitter desc -->
    <meta name="twitter:image" content="https://madalin-fr.github.io/AstigmatismWheelInteraction/assets/preview-image-3.png">
    <!-- <meta name="twitter:site" content="@yourtwitterhandle"> --> <!-- Optional: Add if you have a related Twitter account -->
    <!-- <meta name="twitter:creator" content="@yourtwitterhandle"> --> <!-- Optional: Add if you have a related Twitter account -->

    <style>
        /* Visually hide h1, but keep for SEO/Screen Readers */
        .visually-hidden {
            position: absolute;
            width: 1px;
            height: 1px;
            margin: -1px;
            padding: 0;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            border: 0;
        }

        html,
        body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden; /* Prevent scrollbars */
            background-color: #000000; /* Default BG set via JS, but good to have a fallback */
        }

        canvas {
            position: absolute;
            /* Centering handled by drawing logic relative to width/height */
            /* margin: auto; removed */
            display: block; /* Prevent extra space below canvas */
            /* Accessibility Note: Canvas content is not directly accessible.
               Ensure descriptions and controls provide context. */
            /* Cursor styles handled by JS for panning */
        }

        /* --- Controls Panel Styling --- */
        #controls-container {
            position: absolute;
            /* Default position set via JS/LocalStorage */
            /* top: 1rem; */
            /* left: 1rem; */
            z-index: 10; /* Ensure controls are above canvas */
            display: flex;
            align-items: center;
            gap: 10px;
        }

        #controls-container.reverse {
            flex-direction: row-reverse;
        }

        #drag-handle {
            background-color: rgba(220, 220, 220, 0.8); /* Lighter default handle */
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #666;
            cursor: grab; /* Indicate draggability */
            transition: background-color 0.3s ease, border-color 0.3s ease;
            display: flex; /* Center icon */
            align-items: center;
            justify-content: center;
        }
         #drag-handle:active {
             cursor: grabbing; /* Indicate active drag */
         }

        #drag-handle i { /* Style the icon inside */
            color: #333;
            transition: color 0.3s ease;
        }

        #toggle-menu,
        #toggle-wheel-lock {
            padding: 8px 15px; /* Adjusted padding */
            border-radius: 4px;
            cursor: pointer;
            border: 1px solid #666;
            background-color: rgba(245, 245, 245, 0.85); /* Slightly off-white */
            color: black;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        #toggle-wheel-lock {
            padding: 8px 12px;
        }

        #toggle-wheel-lock.unlocked {
            background-color: rgba(255, 200, 200, 0.85);
        }

        #controls {
            display: none; /* Initially hidden, shown by button */
            position: absolute;
             /* Position relative to #controls-container */
             top: calc(100% + 5px); /* Position below the handle/button */
             left: 0; /* Align with left edge */
            background-color: rgba(245, 245, 245, 0.9); /* Slightly more opaque */
            padding: 1rem;
            border-radius: 8px;
            border: 1px solid #ccc;
            max-height: calc(100vh - 6rem); /* Limit height, adjust as needed */
            overflow-y: auto; /* Allow scrolling if content exceeds height */
            width: 250px; /* Fixed width for the panel */
            opacity: 1;
            transition: background-color 0.3s ease, opacity 0.3s ease, border-color 0.3s ease;
            color: black;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1); /* Subtle shadow */
        }

        #controls label {
            display: block; /* Ensure labels are on their own line */
            margin-top: 8px;
            margin-bottom: 2px;
            font-size: 0.9em;
            font-weight: bold;
        }

        #controls input[type='range'],
        #controls select {
            width: 100%;
            margin-bottom: 8px;
        }
         #controls input[type='color'] {
             width: 50px; /* Smaller color swatch */
             height: 25px;
             padding: 0;
             border: 1px solid #ccc;
             vertical-align: middle;
             margin-left: 5px;
         }

        #controls h3 {
            margin: 0 10px 10px 0; /* Adjust margins */
            font-size: 1.1em;
        }

        #controls #toggle-dark-mode,
        #controls #flip-position {
            background: none;
            border: none;
            font-size: 1.4rem;
            padding: 0px;
            cursor: pointer;
            margin: 0 5px; /* Spacing */
            position: relative;
            color: #333;
            transition: color 0.3s ease;
        }
        #controls #toggle-dark-mode i.fa-sun { color: #FFD700; text-shadow: 0 0 2px #fff;}
        #controls #toggle-dark-mode i.fa-moon { color: #4a4a4a; }


        #toggle-autopilot-1,
        #toggle-autopilot-2 {
            padding: 6px 12px; /* Adjusted padding */
            border-radius: 4px;
            cursor: pointer;
            border: 1px solid #666;
            background-color: rgba(220, 220, 220, 0.8); /* Button background */
            color: black;
            transition: all 0.3s ease;
            margin-bottom: 5px;
            width: 100%; /* Make buttons fill width */
            box-sizing: border-box; /* Include padding/border in width */
            font-weight: bold;
        }
         #toggle-autopilot-1.active, /* Style for active autopilot button */
         #toggle-autopilot-2.active {
            background-color: #a8e6cf; /* Example active color */
            border-color: #7fcdb8;
         }

        /* --- Dark Mode Styles --- */
        body.dark-mode-body { background-color: #1a1a1a; } /* Dark body background */

        #controls-container.dark-mode #drag-handle {
            background-color: rgba(50, 50, 50, 0.9);
            border-color: #777;
        }
        #controls-container.dark-mode #drag-handle i { color: #eee; }
        #controls-container.dark-mode #toggle-menu,
        #controls-container.dark-mode #toggle-wheel-lock {
            background-color: rgba(40, 40, 40, 0.9);
            color: white;
            border-color: #777;
        }

        #controls-container.dark-mode #toggle-wheel-lock.unlocked {
            background-color: rgba(100, 40, 40, 0.9);
        }
        #controls.dark-mode {
            background-color: rgba(30, 30, 30, 0.95);
            color: #eee; /* Light text */
            border-color: #555;
        }
        #controls.dark-mode label { color: #ccc; }
        #controls.dark-mode input[type='color'] { border-color: #555; }
        #controls.dark-mode select { background-color: #333; color: #eee; border-color: #555; }
        #controls.dark-mode input[type='range'] { /* Style range sliders for dark mode if needed */ }
        #controls.dark-mode #toggle-dark-mode,
        #controls.dark-mode #flip-position { color: #ccc; }
        #controls.dark-mode #toggle-dark-mode i.fa-moon { color: #FFFF80; text-shadow: 0 0 3px #aaa;}
        #controls.dark-mode #toggle-dark-mode i.fa-sun { color: #777; text-shadow: none;} /* Dim sun in dark mode */
        #controls.dark-mode #toggle-autopilot-1,
        #controls.dark-mode #toggle-autopilot-2 {
            background-color: rgba(60, 60, 60, 0.9);
            color: white;
            border-color: #888;
        }
        #controls.dark-mode #toggle-autopilot-1.active,
        #controls.dark-mode #toggle-autopilot-2.active {
            background-color: #2a5a4a; /* Darker active color */
            border-color: #4a7a6a;
        }

        /* --- Zoom Controls --- */
        #zoom-controls {
            position: absolute;
            top: 1rem;
            right: 1rem;
            z-index: 10;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        #zoom-controls button {
            background-color: rgba(245, 245, 245, 0.85);
            border: 1px solid #666;
            border-radius: 4px;
            padding: 0; /* Remove padding */
            cursor: pointer;
            font-size: 1.2rem; /* Increase font size */
            font-weight: bold;
            color: black;
            transition: all 0.3s ease;
            width: 35px; /* Fixed width */
            height: 35px; /* Fixed height */
            display: flex; /* Center content */
            align-items: center;
            justify-content: center;
            line-height: 1; /* Ensure '+' and '-' center well */
        }

        #zoom-controls button.dark-mode {
            background-color: rgba(40, 40, 40, 0.9);
            color: white;
            border-color: #777;
        }

    </style>
    <!-- External Libraries -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.3.0/css/all.min.css">
    <script src="https://cdn.jsdelivr.net/npm/interactjs/dist/interact.min.js"></script>

    <!-- Structured Data (Schema.org - JSON-LD) -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "WebPage",
      "name": "Interactive Astigmatism Wheel: Explore & Visualize Online",
      "description": "Explore astigmatism with this interactive online wheel visualization. Adjust line count, colors, rotation, anaglyph 3D, zoom/pan, and autopilot modes. A web-based tool for learning and visual exploration, not a medical diagnosis.",
      "url": "https://madalin-fr.github.io/AstigmatismWheelInteraction/",
      "author": {
        "@type": "Person",
        "name": "Frincu Madalin"
      },
      "license": "http://creativecommons.org/licenses/by-nc-sa/4.0/",
      "keywords": "astigmatism, astigmatism wheel, interactive visualization, eye chart simulation, ophthalmology tool, vision visualization, visual acuity, refractive error, anaglyph 3D vision, interactive eye simulation, web-based vision tool, online astigmatism explorer, learn about astigmatism, javascript canvas animation, zoom, pan",
      "mainEntity": {
        "@type": "WebApplication",
        "name": "Astigmatism Wheel Interactions",
        "description": "An interactive web application for visualizing astigmatism concepts using a rotating wheel chart with customizable parameters, zoom/pan, and autopilot features.",
        "applicationCategory": "VisualizationTool",
        "operatingSystem": "Web/Online",
        "browserRequirements": "Requires JavaScript and HTML5 Canvas support.",
        "featureList": [
          "Multiple visualization modes (Many Lines, Single Line, Pendulum, Anaglyph 3D)",
          "Adjustable line count, color, thickness, length",
          "Customizable background and text colors",
          "Anaglyph 3D mode with adjustable depth and eye colors",
          "Interactive rotation control",
          "Autopilot modes for automatic animation (random jumps or smooth transitions)",
          "Zoom and Pan functionality (mouse wheel/drag, touch pinch/drag)",
          "Dark/Light mode toggle",
          "Draggable controls interface"
        ]
        // Add other relevant properties like author, copyrightHolder, license, url, image if desired
      }
    }
    </script>

</head>

<body>
    <!-- Visually Hidden H1 for SEO -->
    <h1 class="visually-hidden">Interactive Astigmatism Wheel: Explore & Visualize Online</h1>

    <!-- Main Content Area -->
    <main>
        <canvas id="canvas">
            <!-- Fallback content for non-supporting browsers -->
            Your browser does not support the HTML5 canvas element. This interactive visualization requires a modern browser with Canvas support.
        </canvas>

        <!-- Controls container -->
        <div id="controls-container" class="draggable">
            <!-- Handle for dragging the entire controls panel -->
            <div id="drag-handle" title="Drag Controls">
                <i class="fas fa-arrows-alt"></i>
            </div>
            <!-- Button to show/hide the main controls panel -->
            <button id="toggle-menu" title="Show/Hide Controls Menu" aria-expanded="false" aria-controls="controls">Show Controls</button>
            <button id="toggle-wheel-lock" title="Toggle Wheel Position Lock (Currently: Locked)" aria-label="Toggle Wheel Lock">
                <i class="fas fa-lock"></i>
            </button>
            <!-- The actual controls panel -->
            <div id="controls" role="region" aria-labelledby="controls-heading" aria-hidden="true">
                <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom: 10px;">
                    <h3 id="controls-heading">Adjust Settings</h3>
                    <!-- Dark mode toggle button -->
                    <button id="toggle-dark-mode" title="Toggle Dark/Light Mode">
                        <i class="fas fa-sun"></i> <!-- Icon changes via JS -->
                    </button>
                    <!-- Button to flip control handle/menu order -->
                    <button id="flip-position" title="Flip Controls Position">
                        <i class="fas fa-exchange-alt"></i>
                    </button>
                </div>

                <label for="visualization-mode">Mode:</label>
                <select id="visualization-mode" style="width: 100%; margin-bottom: 10px;">
                    <option value="many">Many Lines</option>
                    <option value="single">Single Line</option>
                    <option value="pendulum">Pendulum</option>
                    <option value="anaglyph">Anaglyph 3D</option>
                    <option value="v-diagram">V-Diagram</option>
                </select>
                <br>

                <label for="opacity-slider">Controls Opacity:</label>
                <input type="range" id="opacity-slider" min="0.1" max="1.0" step="0.1" value="1.0">
                <br>

                <!-- Controls shown/hidden based on mode -->
                <div id="radiating-line-count-container">
                    <label for="radiating-line-count">Radiating Line Count:</label>
                    <input type="range" id="radiating-line-count" min="2" max="72" value="12">
                </div>

                <div id="line-color-container">
                    <label for="line-color">Line Color:</label>
                    <input type="color" id="line-color" value="#7B68EE">
                </div>

                <!-- Label text updated dynamically via JS -->
                <div> <!-- Wrap label/input for better control -->
                    <label for="special-line-color" id="special-line-color-label">Special Line Color:</label>
                    <input type="color" id="special-line-color" value="#FFFFFF">
                </div>
                <br>

                <!-- Anaglyph Specific Controls -->
                <div id="anaglyph-color-pickers" style="display: none;">
                    <label for="anaglyph-left-color">Left Eye Color:</label>
                    <input type="color" id="anaglyph-left-color" value="#ff0000">
                    <br>
                    <label for="anaglyph-right-color">Right Eye Color:</label>
                    <input type="color" id="anaglyph-right-color" value="#00ffff">
                    <br>
                </div>
                <div id="depth-offset-container" style="display: none;">
                    <label for="depth-offset">Anaglyph Depth Offset:</label>
                    <input type="range" id="depth-offset" min="-50" max="50" value="5"> <!-- Allow negative depth -->
                    <br>
                </div>
                <!-- End Anaglyph Specific -->

                <!-- Pendulum Specific Controls -->
                <div id="pendulum-size-container" style="display: none;">
                    <label for="pendulum-thickness">Pendulum Thickness:</label>
                    <input type="range" id="pendulum-thickness" min="1" max="500" value="20">
                </div>
                <!-- End Pendulum Specific -->

                <!-- V-Diagram Specific Controls -->
                <div id="v-angle-container" style="display: none;">
                    <label for="v-angle">V-Angle:</label>
                    <input type="range" id="v-angle" min="10" max="90" value="30">
                </div>
                <!-- End V-Diagram Specific -->


                <label for="bg-color">Background Color:</label>
                <input type="color" id="bg-color" value="#000000"> <!-- Initial value overridden by JS/LocalStorage -->
                <br>

                <label for="text-color">Text Color:</label>
                <input type="color" id="text-color" value="#FFFFFF"> <!-- Initial value overridden by JS/LocalStorage -->
                <br>

                <label for="circle-outline-color">Circle Outline Color:</label>
                <input type="color" id="circle-outline-color" value="#ffffff"> <!-- Initial value overridden by JS/LocalStorage -->
                <br>

                <!-- Pan Controls (Now control originX/Y) -->
                <label for="horizontal-offset">Horizontal Pan:</label>
                <input type="range" id="horizontal-offset" min="-800" max="800" value="0" step="1"> <!-- Range set dynamically -->
                <br>
                <label for="vertical-offset">Vertical Pan:</label>
                <input type="range" id="vertical-offset" min="-800" max="800" value="0" step="1"> <!-- Range set dynamically -->
                <br>
                <!-- End Pan Controls -->

                <label for="arc-offset">Circle Radius Offset:</label>
                <input type="range" id="arc-offset" min="-200" max="1200" value="0">
                <br>
                <label for="circle-outline-dash-density">Arc Dash Density:</label>
                <input type="range" id="circle-outline-dash-density" min="1" max="48" value="15">
                <br>
                <label for="text-size">Text Size (px):</label>
                <input type="range" id="text-size" min="8" max="72" value="14">
                <br>
                <label for="text-distance">Text Distance (Factor):</label>
                <input type="range" id="text-distance" min="1.0" max="5.0" step="0.1" value="1.6">
                <br>

                <label for="line-thickness">Line Thickness:</label>
                <input type="range" id="line-thickness" min="1" max="40" value="4">
                <br>
                <label for="line-length">Line Length (Factor):</label>
                <input type="range" id="line-length" min="0.1" max="4.0" step="0.1" value="1.0">
                <br>

                <label for="rotation-velocity">Rotation Velocity:</label>
                <input type="range" id="rotation-velocity" min="0.1" max="10" step="0.1" value="1">
                <br>
                <!-- MOVED ROTATION CHECKBOXES HERE -->
                <div style="margin-top: 5px; margin-bottom: 10px;"> <!-- Adjusted margin -->
                    <input type="checkbox" id="rotate-clockwise" checked>
                    <label for="rotate-clockwise" style="display: inline; margin: 0 5px 0 0;">Rotate Clockwise</label> <br>
                    <input type="checkbox" id="rotate-counterclockwise">
                    <label for="rotate-counterclockwise" style="display: inline; margin: 0 5px 0 0;">Rotate Counter-Clockwise</label>
                </div>
                <!-- END MOVED ROTATION CHECKBOXES -->

                <label for="autopilot-speed">Autopilot Speed:</label>
                <input type="range" id="autopilot-speed" min="5" max="40" value="10">
                <br>
                <!-- Autopilot Walk Range Control (influences target offset calculation) -->
                <label for="autopilot-walk-range">Autopilot Pan Range (% Width/Height):</label>
                <input type="range" id="autopilot-walk-range" min="0" max="90" value="30">
                <br>

                <!-- Autopilot Toggles -->
                <div style="margin-top: 10px;"> <!-- Add spacing -->
                    <button id="toggle-autopilot-1" title="Start/Stop Autopilot Mode 1 (Smooth Rotation, Random Jumps)">Start Autopilot 1</button>
                </div>
                <div>
                    <button id="toggle-autopilot-2" title="Start/Stop Autopilot Mode 2 (Smooth Rotation, Smooth Transitions)">Start Autopilot 2</button>
                </div>

            </div>
        </div>

        <!-- Zoom controls -->
        <div id="zoom-controls">
            <button id="zoom-in" title="Zoom In (+)">+</button>
            <button id="zoom-out" title="Zoom Out (-)">-</button>
        </div>

    </main> <!-- End Main Content Area -->

    <script>
        // --- Utility Functions ---

        /**
         * Standardizes a color string (e.g., 'blue', '#f00', 'rgb(255,0,0)')
         * into a lowercase 6-digit hex format (e.g., '#ff0000') using the canvas API.
         * @param {string} str - The color string to standardize.
         * @returns {string} The standardized hex color string, or the original if parsing fails.
         */
        function standardize_color(str) {
            // Optimization: If already hex6, return early
            if (typeof str === 'string' && /^#[0-9a-f]{6}$/i.test(str)) {
                return str.toLowerCase();
            }
            try {
                // Use a temporary canvas context to parse the color
                var ctx = document.createElement('canvas').getContext('2d');
                ctx.fillStyle = str;
                let standardized = ctx.fillStyle;
                // Ensure it's lowercase hex6 if possible
                if (standardized.startsWith('#') && standardized.length === 7) {
                    return standardized.toLowerCase();
                }
                 // If canvas returns rgb/rgba etc., return that as fallback (though hex is preferred)
                return standardized;
            } catch (e) {
                 console.warn("Could not standardize color:", str, e);
                 return str; // Return original on error
            }
        }

        /**
         * Sets the background color of the HTML body.
         * @param {string} color - A valid CSS color string.
         */
        function setBackgroundColor(color) {
            document.body.style.backgroundColor = color;
        }

        // --- Local Storage Functions ---

        /**
         * Safely retrieves a value from localStorage.
         * @param {string} key - The key to retrieve.
         * @returns {string | null} The retrieved value, or null if not found or error.
         */
        function getLocalStorageValue(k) {
            try {
                return localStorage.getItem(k);
            } catch (error) {
                console.error("Error reading from localStorage:", k, error);
                return null;
            }
        }

        /**
         * Safely saves a value to localStorage.
         * @param {string} key - The key to save under.
         * @param {string} value - The value to save.
         */
        function setLocalStorageValue(k, v) {
            try {
                localStorage.setItem(k, String(v)); // Ensure value is string
            } catch (error) {
                 console.error("Error writing to localStorage:", k, v, error);
                 // Consider handling QuotaExceededError specifically if needed
            }
        }

        /**
         * Initializes a localStorage key with a default value if it doesn't exist.
         * @param {string} key - The key to initialize.
         * @param {string} defaultValue - The default value to set.
         */
        function initializeLocalStorage(key, defaultValue) {
            if (getLocalStorageValue(key) === null) {
                setLocalStorageValue(key, defaultValue);
            }
        }

        /**
         * Converts an angle (0-360) to its corresponding label on the astigmatism wheel (0Â°-180Â°).
         * Uses integer degrees for display.
         * @param {number} num - The angle in degrees (0-360).
         * @returns {string} The formatted angle label (e.g., "90Â°").
         */
        function angleName(num) {
             // Normalize angle to be strictly within [0, 360)
            num = ((num % 360) + 360) % 360;

            // Map to 0-180 range for display
            let displayAngle;
            if (num >= 0 && num < 180) {
                 displayAngle = num;
            } else { // 180 to 359.99...
                 displayAngle = num - 180;
            }

            // Special case for angles very close to 0 or 180 for precision
            if (Math.abs(displayAngle) < 0.01 || Math.abs(displayAngle - 180) < 0.01) {
                return "0Â°";
            } else if (Math.abs(displayAngle - 90) < 0.01) {
                return "90Â°"
            } else {
                 return Math.round(displayAngle) + "Â°";
            }
        }


        // --- Initialization and Setup ---

        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d", { alpha: false }); // Optimize if no transparency needed behind canvas
        context.imageSmoothingEnabled = true; // Enable anti-aliasing by default

        // Canvas dimensions (updated on resize)
        let canvasHeight = window.innerHeight;
        let canvasWidth = window.innerWidth;
        canvas.width = canvasWidth;
        canvas.height = canvasHeight;

        // Base radius for drawing elements (updated on resize)
        let radius = Math.min(canvasWidth, canvasHeight) / 4.5; // Slightly smaller for padding

        // --- Zoom and Pan Functionality ---
        let scale = 1.0;                // Current zoom level
        const minScale = 0.1;           // Minimum zoom out
        const maxScale = 10.0;          // Maximum zoom in
        let zoomFactor = 1.1;           // How much to zoom per step
        // originX/Y represent the translation offset in the canvas transform.
        // These are controlled by panning (mouse/touch drag) and the Pan sliders.
        let originX = 0;
        let originY = 0;
        let isDragging = false;         // Is the user currently dragging the canvas?
        let isPinching = false;         // Is the user currently pinch-zooming?
        let lastX = 0;                  // Last mouse/touch X for drag calculation
        let lastY = 0;                  // Last mouse/touch Y for drag calculation
        let pinchStartDistance = 0;     // Initial distance between fingers for pinch zoom
        let isPointerLocked = false;    // Is pointer lock currently active?
        let isWheelLocked = true;       // Is the wheel position locked (restricted to stay visible)?


        // --- Default Settings & LocalStorage Initialization ---
        const defaultSettings = {
            mode: 'many',
            // Colors (standardized to lowercase hex6)
            color_many: '#7b68ee', color2_many: '#ffffff',
            color_single: '#ffffff', color2_single: '#ffffff', // color2 used for single line
            color_pendulum: '#ffd700', color2_pendulum: '#c0c0c0',
            color3: '#ffffff', // Circle Outline (common)
            anaglyphLeftColor: '#ff0000', anaglyphRightColor: '#00ffff',
            bgColor_many: '#000000', bgColor_single: '#000000',
            bgColor_pendulum: '#2f4f4f', bgColor_anaglyph: '#000000',
            textColor_many: '#ffffff', textColor_single: '#ffffff',
            textColor_pendulum: '#ffffff', textColor_anaglyph: '#ffffff', // Drawn twice
            // Numeric/Boolean settings
            textSize: '14',
            pendulumThickness: '20',
            textDistance: '1.6',
            startAngle: '0',
            // horizontalOffset, verticalOffset are deprecated -> use originX, originY
            originX: '0', // Default pan X
            originY: '0', // Default pan Y
            arcOffset: '0',
            rotationVelocity: '1.0',
            lineLength: '1.0',
            isDarkMode: 'true', // Default to dark mode
            isReversed: 'false', // Controls layout LTR/RTL
            lineThickness: '4',
            radiatingLineCount: '12', // Clock face default
            autopilotSpeed: '10',
            rotateClockwise: 'true',
            rotateCounterclockwise: 'false',
            opacity: '0.9', // Controls panel opacity
            autopilotWalkRange: '30', // Percentage for autopilot panning range
            controlsPosition: JSON.stringify({ x: 16, y: 16 }), // Default controls pos (top-left)
            isWheelLocked: 'true', // Wheel position locked by default
            circleOutlineDashDensity: '15',
            depthOffset: '5', // Anaglyph depth
            // scale: '1.0', // Could save scale too, but start at 1 for now
        };

        // Initialize LS keys *before* retrieving values
        for (const key in defaultSettings) {
            initializeLocalStorage(key, defaultSettings[key]);
        }

        // --- Load Settings from LocalStorage ---

        // Helper to get mode-specific settings, falling back to defaults
        function getModeSetting(baseKey, currentMode) {
             const modeSpecificKey = `${baseKey}_${currentMode}`;
             const value = getLocalStorageValue(modeSpecificKey);
             if (value !== null) return value; // Return stored value if exists
             if (defaultSettings[modeSpecificKey] !== undefined) return defaultSettings[modeSpecificKey]; // Fallback mode default
             console.warn(`No specific or default setting found for ${modeSpecificKey}`);
             return defaultSettings[baseKey] || null; // Absolute fallback or null
        }

        // Load settings, using defaults from defaultSettings object if not found in LS
        let mode = getLocalStorageValue('mode') || defaultSettings.mode;
        let color = standardize_color(getModeSetting('color', mode));
        let color2 = standardize_color(getModeSetting('color2', mode));
        let color3 = standardize_color(getLocalStorageValue('color3') || defaultSettings.color3);
        let bgColor = standardize_color(getModeSetting('bgColor', mode));
        let textColor = standardize_color(getModeSetting('textColor', mode));
        let anaglyphLeftColor = standardize_color(getLocalStorageValue('anaglyphLeftColor') || defaultSettings.anaglyphLeftColor);
        let anaglyphRightColor = standardize_color(getLocalStorageValue('anaglyphRightColor') || defaultSettings.anaglyphRightColor);

        let textSize = parseInt(getLocalStorageValue('textSize') || defaultSettings.textSize);
        let pendulumThickness = parseInt(getLocalStorageValue('pendulumThickness') || defaultSettings.pendulumThickness);
        let textDistance = parseFloat(getLocalStorageValue('textDistance') || defaultSettings.textDistance);
        let startAngle = parseFloat(getLocalStorageValue('startAngle') || defaultSettings.startAngle);
        originX = parseFloat(getLocalStorageValue('originX') || defaultSettings.originX); // Load pan X
        originY = parseFloat(getLocalStorageValue('originY') || defaultSettings.originY); // Load pan Y
        let arcOffset = parseInt(getLocalStorageValue('arcOffset') || defaultSettings.arcOffset);
        let rotationVelocity = parseFloat(getLocalStorageValue('rotationVelocity') || defaultSettings.rotationVelocity);
        let lineLength = parseFloat(getLocalStorageValue('lineLength') || defaultSettings.lineLength);
        let isDarkMode = (getLocalStorageValue('isDarkMode') || defaultSettings.isDarkMode) === 'true';
        let isReversed = (getLocalStorageValue('isReversed') || defaultSettings.isReversed) === 'true';
        let lineThickness = parseInt(getLocalStorageValue('lineThickness') || defaultSettings.lineThickness);
        let radiatingLineCount = parseInt(getLocalStorageValue('radiatingLineCount') || defaultSettings.radiatingLineCount);
        let autopilotSpeed = parseInt(getLocalStorageValue('autopilotSpeed') || defaultSettings.autopilotSpeed);
        let rotateClockwise = (getLocalStorageValue('rotateClockwise') || defaultSettings.rotateClockwise) === 'true';
        let rotateCounterclockwise = (getLocalStorageValue('rotateCounterclockwise') || defaultSettings.rotateCounterclockwise) === 'true';
        let opacity = parseFloat(getLocalStorageValue('opacity') || defaultSettings.opacity);
        let autopilotWalkRange = parseInt(getLocalStorageValue('autopilotWalkRange') || defaultSettings.autopilotWalkRange);
        let circleOutlineDashDensity = parseInt(getLocalStorageValue('circleOutlineDashDensity') || defaultSettings.circleOutlineDashDensity);
        let depthOffset = parseInt(getLocalStorageValue('depthOffset') || defaultSettings.depthOffset);
        isWheelLocked = (getLocalStorageValue('isWheelLocked') || defaultSettings.isWheelLocked) === 'true';
        // scale = parseFloat(getLocalStorageValue('scale') || defaultSettings.scale); // Load scale if saved

        // Initialize pendulum angle (use startAngle if specific pendulum angle not saved)
        let pendulumAngle = parseFloat(getLocalStorageValue('pendulumAngle') || startAngle);

        // --- DOM Element References ---
        const controlsContainer = document.getElementById('controls-container');
        const controls = document.getElementById('controls');
        const toggleMenuButton = document.getElementById('toggle-menu');
        const toggleWheelLockButton = document.getElementById('toggle-wheel-lock');
        const flipPositionButton = document.getElementById('flip-position');
        const horizontalOffsetSlider = document.getElementById('horizontal-offset'); // Now the Pan X slider
        const verticalOffsetSlider = document.getElementById('vertical-offset');     // Now the Pan Y slider
        const autopilotWalkRangeSlider = document.getElementById('autopilot-walk-range');
        const toggleDarkModeButton = document.getElementById('toggle-dark-mode');
        const toggleAutopilot1Button = document.getElementById("toggle-autopilot-1");
        const toggleAutopilot2Button = document.getElementById("toggle-autopilot-2");
        const rotateClockwiseToggle = document.getElementById('rotate-clockwise');
        const rotateCounterClockwiseToggle = document.getElementById('rotate-counterclockwise');
        // ... (add other element refs if needed frequently)


        // --- UI Initialization Function ---

        /**
         * Sets the min/max range for the pan sliders based on canvas dimensions,
         * current scale, and the effective radius of the drawn circle, ensuring
         * some part of the circle always remains visible.
         */
        function updatePanSliderLimits() {
            if (isWheelLocked) {
                // LOCKED: Restrict panning to keep wheel visible
                const effectiveRadius = (radius * 1.7 + arcOffset);
                const logicalCenterX = canvasWidth / 2;
                const logicalCenterY = canvasHeight / 2;

                // Allow panning until 25% of the radius is off-screen (75% visible)
                const maxOriginX = canvasWidth - (logicalCenterX + 0.75 * effectiveRadius) * scale;
                const minOriginX = -(logicalCenterX - 0.75 * effectiveRadius) * scale;
                const maxOriginY = canvasHeight - (logicalCenterY + 0.75 * effectiveRadius) * scale;
                const minOriginY = -(logicalCenterY - 0.75 * effectiveRadius) * scale;

                // Apply the calculated limits to the sliders
                horizontalOffsetSlider.min = minOriginX;
                horizontalOffsetSlider.max = maxOriginX;
                verticalOffsetSlider.min = minOriginY;
                verticalOffsetSlider.max = maxOriginY;

                // Clamp current origin to the *new* limits immediately
                originX = Math.max(minOriginX, Math.min(originX, maxOriginX));
                originY = Math.max(minOriginY, Math.min(originY, maxOriginY));
            } else {
                // UNLOCKED: Allow free panning anywhere (large limits)
                const freeLimit = 10000;
                horizontalOffsetSlider.min = -freeLimit;
                horizontalOffsetSlider.max = freeLimit;
                verticalOffsetSlider.min = -freeLimit;
                verticalOffsetSlider.max = freeLimit;
                // Don't clamp origin when unlocked
            }

            // Update slider thumbs to reflect origin values
            horizontalOffsetSlider.value = originX;
            verticalOffsetSlider.value = originY;
        }


        function initializeUI() {
            // Set control values from loaded settings
            document.getElementById('line-color').value = color;
            document.getElementById('special-line-color').value = color2;
            document.getElementById('circle-outline-color').value = color3;
            document.getElementById('bg-color').value = bgColor;
            document.getElementById('text-color').value = textColor;
            document.getElementById('line-thickness').value = lineThickness;
            document.getElementById('radiating-line-count').value = radiatingLineCount;
            // Set Pan Slider values FIRST
            horizontalOffsetSlider.value = originX;
            verticalOffsetSlider.value = originY;
            // THEN set their limits (which might clamp the values)
            updatePanSliderLimits(); // Set dynamic pan slider limits
            document.getElementById('arc-offset').value = arcOffset;
            document.getElementById('line-length').value = lineLength;
            document.getElementById('text-size').value = textSize;
            document.getElementById('pendulum-thickness').value = pendulumThickness;
            document.getElementById('text-distance').value = textDistance;
            document.getElementById('rotation-velocity').value = rotationVelocity;
            document.getElementById('autopilot-speed').value = autopilotSpeed;
            rotateClockwiseToggle.checked = rotateClockwise;
            rotateCounterClockwiseToggle.checked = rotateCounterclockwise;
            document.getElementById('opacity-slider').value = opacity;
            document.getElementById('visualization-mode').value = mode;
            autopilotWalkRangeSlider.value = autopilotWalkRange; // Autopilot range setting
            document.getElementById('circle-outline-dash-density').value = circleOutlineDashDensity;
            document.getElementById('depth-offset').value = depthOffset;
            document.getElementById('anaglyph-left-color').value = anaglyphLeftColor;
            document.getElementById('anaglyph-right-color').value = anaglyphRightColor;

            // Apply initial visual state
            setBackgroundColor(bgColor);
            applyDarkMode(isDarkMode); // Apply dark/light mode styles
            controls.style.opacity = opacity;
            toggleControlVisibility(); // Show/hide controls based on mode
            updateTextPlaceholder(); // Update dynamic labels

            // Position controls container based on saved position
            const savedPosition = JSON.parse(getLocalStorageValue('controlsPosition') || defaultSettings.controlsPosition);
            controlsContainer.style.transform = `translate(${savedPosition.x}px, ${savedPosition.y}px)`;
            controlsContainer.setAttribute('data-x', savedPosition.x);
            controlsContainer.setAttribute('data-y', savedPosition.y);
            if (isReversed) {
                controlsContainer.classList.add('reverse');
            }

            // Initialize Pan/Zoom event listeners
            initializeZoomAndPan();

            // Apply wheel lock button state
            updateWheelLockButton();

            // Apply initial canvas transform (scale and pan) and draw
            updateCanvasTransform();
        }

        // --- Run Initialization ---
        // Use DOMContentLoaded for reliability
        document.addEventListener('DOMContentLoaded', initializeUI);


        // --- Draggable Controls Panel (InteractJS) ---
        interact('.draggable').draggable({
            allowFrom: '#drag-handle', // Only allow dragging from the handle
            inertia: true, // Add some inertia for smoother feel
            modifiers: [
                interact.modifiers.restrictRect({
                    // Restrict dragging to the viewport bounds dynamically
                    restriction: () => {
                        const viewportWidth = window.innerWidth;
                        const viewportHeight = window.innerHeight;
                        // Return a rectangle representing the viewport
                        return { x: 0, y: 0, width: viewportWidth, height: viewportHeight };
                    },
                    // Apply restriction during drag, not just at the end
                    endOnly: false
                })
            ],
            autoScroll: false, // Disable auto-scrolling
            listeners: {
                move(event) { // Fired during drag
                    const target = event.target;
                    // Keep track of the position using data attributes
                    const x = (parseFloat(target.getAttribute('data-x')) || 0) + event.dx;
                    const y = (parseFloat(target.getAttribute('data-y')) || 0) + event.dy;

                    // Apply the translation via CSS transform
                    target.style.transform = `translate(${x}px, ${y}px)`;

                    // Update the data attributes
                    target.setAttribute('data-x', x);
                    target.setAttribute('data-y', y);
                },
                end(event) { // Fired when drag ends
                     // Save the final position to localStorage
                     const target = event.target;
                     const x = parseFloat(target.getAttribute('data-x')) || 0;
                     const y = parseFloat(target.getAttribute('data-y')) || 0;
                     setLocalStorageValue('controlsPosition', JSON.stringify({ x: x, y: y }));
                }
            }
        });


        // --- General Controls Event Listeners ---

        // Toggle Controls Panel Visibility
        toggleMenuButton.addEventListener('click', () => {
            const isVisible = controls.style.display === 'block';
            controls.style.display = isVisible ? 'none' : 'block';
            toggleMenuButton.textContent = isVisible ? 'Show Controls' : 'Hide Controls';
            toggleMenuButton.setAttribute('aria-expanded', !isVisible);
            controls.setAttribute('aria-hidden', isVisible);
        });
        // Set initial ARIA state
        toggleMenuButton.setAttribute('aria-expanded', controls.style.display === 'block');
        controls.setAttribute('aria-hidden', controls.style.display !== 'block');

        // Flip Controls Handle/Menu Order
        flipPositionButton.addEventListener('click', () => {
            isReversed = !isReversed;
            setLocalStorageValue('isReversed', isReversed); // Save preference
            controlsContainer.classList.toggle('reverse');
        });

        // Toggle Wheel Lock
        toggleWheelLockButton.addEventListener('click', () => {
            isWheelLocked = !isWheelLocked;
            setLocalStorageValue('isWheelLocked', isWheelLocked);
            updateWheelLockButton();
            updatePanSliderLimits(); // Recalculate limits based on new lock state
            updateCanvasTransform(); // Redraw with potentially clamped position
        });

        // Helper function to update wheel lock button appearance
        function updateWheelLockButton() {
            const icon = toggleWheelLockButton.querySelector('i');
            if (isWheelLocked) {
                icon.classList.remove('fa-unlock');
                icon.classList.add('fa-lock');
                toggleWheelLockButton.classList.remove('unlocked');
                toggleWheelLockButton.title = 'Toggle Wheel Position Lock (Currently: Locked)';
            } else {
                icon.classList.remove('fa-lock');
                icon.classList.add('fa-unlock');
                toggleWheelLockButton.classList.add('unlocked');
                toggleWheelLockButton.title = 'Toggle Wheel Position Lock (Currently: Unlocked)';
            }
        }


        // --- Input Element Event Handling (Sliders, Pickers, Select) ---
        const inputElementIds = [
            'visualization-mode', 'horizontal-offset', 'pendulum-thickness', 'vertical-offset',
            'arc-offset', 'line-length', 'rotation-velocity', 'line-thickness',
            'radiating-line-count', 'line-color', 'special-line-color', 'text-size',
            'text-distance', 'bg-color', 'text-color', 'circle-outline-color',
            'opacity-slider', 'autopilot-walk-range', 'circle-outline-dash-density',
            'depth-offset', 'anaglyph-left-color', 'anaglyph-right-color'
        ];

        inputElementIds.forEach(id => {
            const element = document.getElementById(id);
            if (!element) {
                console.warn(`Element with ID '${id}' not found.`);
                return;
            }
            element.addEventListener('input', function () {
                 let needsRedraw = true; // Assume redraw needed unless specified otherwise
                 let updateTransform = false; // Flag if transform needs update

                switch (id) {
                    case 'visualization-mode':
                         mode = this.value;
                         setLocalStorageValue('mode', mode);
                         // Load/apply settings specific to the new mode
                         color = standardize_color(getModeSetting('color', mode));
                         color2 = standardize_color(getModeSetting('color2', mode));
                         bgColor = standardize_color(getModeSetting('bgColor', mode));
                         textColor = standardize_color(getModeSetting('textColor', mode));
                         // Update UI elements for the new mode
                         applyColorsToControls();
                         setBackgroundColor(bgColor);
                         toggleControlVisibility();
                         updateTextPlaceholder();
                         needsRedraw = true;
                         break;

                    // PAN SLIDERS - Update originX/Y and trigger transform update
                    case 'horizontal-offset':
                        originX = parseFloat(this.value);
                        setLocalStorageValue('originX', originX);
                        updateTransform = true;
                        needsRedraw = false; // updateCanvasTransform handles redraw
                        break;
                    case 'vertical-offset':
                        originY = parseFloat(this.value);
                        setLocalStorageValue('originY', originY);
                        updateTransform = true;
                        needsRedraw = false; // updateCanvasTransform handles redraw
                        break;

                    // Other visual parameter updates
                    case 'pendulum-thickness': pendulumThickness = parseInt(this.value); setLocalStorageValue('pendulumThickness', pendulumThickness); break;
                    case 'arc-offset':
                        arcOffset = parseInt(this.value);
                        setLocalStorageValue('arcOffset', arcOffset);
                        updatePanSliderLimits(); // Limits depend on radius/offset
                        needsRedraw = true;
                        break;
                    case 'line-length': lineLength = parseFloat(this.value); setLocalStorageValue('lineLength', lineLength); break;
                    case 'rotation-velocity': rotationVelocity = parseFloat(this.value); setLocalStorageValue('rotationVelocity', rotationVelocity); break;
                    case 'line-thickness': lineThickness = parseInt(this.value); setLocalStorageValue('lineThickness', lineThickness); break;
                    case 'radiating-line-count': radiatingLineCount = parseInt(this.value); setLocalStorageValue('radiatingLineCount', radiatingLineCount); break; // Corrected LS Key
                    case 'text-size': textSize = parseInt(this.value); setLocalStorageValue('textSize', textSize); break;
                    case 'text-distance': textDistance = parseFloat(this.value); setLocalStorageValue('textDistance', textDistance); break;
                    case 'circle-outline-dash-density': circleOutlineDashDensity = parseInt(this.value); setLocalStorageValue('circleOutlineDashDensity', circleOutlineDashDensity); break;
                    case 'depth-offset': depthOffset = parseInt(this.value); setLocalStorageValue('depthOffset', depthOffset); needsRedraw = (mode === 'anaglyph'); break;

                    // Color updates (store per mode where applicable)
                    case 'line-color': color = standardize_color(this.value); setLocalStorageValue('color_' + mode, color); break;
                    case 'special-line-color': color2 = standardize_color(this.value); setLocalStorageValue('color2_' + mode, color2); break;
                    case 'text-color': textColor = standardize_color(this.value); setLocalStorageValue('textColor_' + mode, textColor); break;
                    case 'circle-outline-color': color3 = standardize_color(this.value); setLocalStorageValue('color3', color3); break; // Common setting
                    case 'anaglyph-left-color': anaglyphLeftColor = standardize_color(this.value); setLocalStorageValue('anaglyphLeftColor', anaglyphLeftColor); needsRedraw = (mode === 'anaglyph'); break;
                    case 'anaglyph-right-color': anaglyphRightColor = standardize_color(this.value); setLocalStorageValue('anaglyphRightColor', anaglyphRightColor); needsRedraw = (mode === 'anaglyph'); break;

                    case 'bg-color':
                        bgColor = standardize_color(this.value);
                        setLocalStorageValue('bgColor_' + mode, bgColor);
                        setBackgroundColor(bgColor);
                        // Optional: Auto-calculate anaglyph colors based on BG
                        // if (mode === 'anaglyph' && shouldAutoCalcAnaglyph) { ... }
                        break;

                    // Non-drawing updates
                    case 'opacity-slider':
                        opacity = parseFloat(this.value);
                        setLocalStorageValue('opacity', opacity);
                        controls.style.opacity = opacity;
                        needsRedraw = false;
                        break;
                    case 'autopilot-walk-range':
                        autopilotWalkRange = parseInt(this.value);
                        setLocalStorageValue('autopilotWalkRange', autopilotWalkRange);
                        needsRedraw = false; // Doesn't directly affect drawing unless autopilot recalculates target
                        break;
                 }

                // Apply canvas transform if needed (for pan sliders)
                if (updateTransform) {
                    // updateCanvasTransform calls draw via requestAnimationFrame if not animating
                    updateCanvasTransform();
                }
                // Request redraw if needed and not animating or handled by transform update
                else if (needsRedraw && !shouldAnimate) {
                     // updatePanSliderLimits might have already clamped origin, ensure redraw happens
                     requestAnimationFrame(draw);
                }
            });
        });

        // Helper to update the color picker UI elements
        function applyColorsToControls() {
            document.getElementById('line-color').value = color;
            document.getElementById('special-line-color').value = color2;
            document.getElementById('bg-color').value = bgColor;
            document.getElementById('text-color').value = textColor;
            document.getElementById('circle-outline-color').value = color3;
            document.getElementById('anaglyph-left-color').value = anaglyphLeftColor;
            document.getElementById('anaglyph-right-color').value = anaglyphRightColor;
        }


        // --- Resize and Key Event Handling ---

        function handleResize() {
            // Update canvas dimensions
            canvasWidth = window.innerWidth;
            canvasHeight = window.innerHeight;
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;

            // Recalculate base radius
            radius = Math.min(canvasWidth, canvasHeight) / 4.5;

            // --- Clamp Controls Panel Position ---
            const currentX = parseFloat(controlsContainer.getAttribute('data-x')) || 0;
            const currentY = parseFloat(controlsContainer.getAttribute('data-y')) || 0;
            const panelRect = controlsContainer.getBoundingClientRect();
            const panelWidth = panelRect.width || 280;
            const panelHeight = panelRect.height || 50;
            const maxX = window.innerWidth - panelWidth - 5;
            const maxY = window.innerHeight - panelHeight - 5;
            const clampedX = Math.max(0, Math.min(currentX, maxX));
            const clampedY = Math.max(0, Math.min(currentY, maxY));
            if (clampedX !== currentX || clampedY !== currentY) {
                controlsContainer.style.transform = `translate(${clampedX}px, ${clampedY}px)`;
                controlsContainer.setAttribute('data-x', clampedX);
                controlsContainer.setAttribute('data-y', clampedY);
                setLocalStorageValue('controlsPosition', JSON.stringify({ x: clampedX, y: clampedY }));
            }
            // --- End Clamp Controls Panel ---

            // Update Pan Slider Limits on resize
            updatePanSliderLimits();

            // Apply current transform (scale/pan) to the resized canvas and redraw
            updateCanvasTransform();
        }
        window.addEventListener("resize", handleResize);

        // Keyboard state tracking
        let pressedKeys = {};
        window.addEventListener("keydown", function (event) {
            if (event.key === 'Shift' || event.key === 'Control' || event.key === 'Alt' || event.key === 'Meta') return;
            pressedKeys[event.key.toLowerCase()] = true;
            
            handleKeyPresses(event); // Call the old handler
            
            // Handle Escape key to exit pointer lock
            if (event.key === 'Escape' && isPointerLocked) {
                document.exitPointerLock();
                event.preventDefault();
            }
            
             // Prevent default for handled keys
             if (['arrowup', 'arrowdown', 'arrowleft', 'arrowright', '+', '-', '=', '_', 'm', 'r', 'c', 'w', 's', 'a', 'd', 'q', 'e'].includes(event.key.toLowerCase())) {
                 event.preventDefault();
             }
        });

        window.addEventListener("keyup", function (event) {
             delete pressedKeys[event.key.toLowerCase()];
        });

              
        function handleKeyPresses(event) {
            let offsetStep = 10; // Pan by 10 screen pixels per key press
            let angleStep = Math.max(0.5, rotationVelocity);
            let hasChanged = false;
            let panChanged = false;
            const key = event.key.toLowerCase();

            // Rotation
            if (pressedKeys["a"] || pressedKeys["arrowleft"]) {
                if (mode === "pendulum") { pendulumAngle -= angleStep; } else { startAngle -= angleStep; }
                hasChanged = true;
            }
            if (pressedKeys["d"] || pressedKeys["arrowright"]) {
                if (mode === "pendulum") { pendulumAngle += angleStep; } else { startAngle += angleStep; }
                hasChanged = true;
            }
            // Panning (using originX/Y)
            if (pressedKeys["w"] || pressedKeys["arrowup"]) { originY += offsetStep; panChanged = true; }
            if (pressedKeys["s"] || pressedKeys["arrowdown"]) { originY -= offsetStep; panChanged = true; }
            if (pressedKeys["q"]) { originX += offsetStep; panChanged = true; }
            if (pressedKeys["e"]) { originX -= offsetStep; panChanged = true; }

            // Single Press Actions
            if (event.type === 'keydown' && !event.repeat) {
                if (key === "m") {
                    const modes = ['many', 'single', 'pendulum', 'anaglyph'];
                    const currentModeIndex = modes.indexOf(mode);
                    const nextModeIndex = (currentModeIndex + 1) % modes.length;
                    const modeSelect = document.getElementById('visualization-mode');
                    modeSelect.value = modes[nextModeIndex];
                    modeSelect.dispatchEvent(new Event('input', { bubbles: true }));
                    hasChanged = false; // Handled by input event
                }
                if (key === "r") { // Reset View (Zoom/Pan)
                    scale = 1.0;
                    originX = 0;
                    originY = 0;
                    panChanged = true; // Will trigger updatePanFromInteraction
                    hasChanged = false;
                }
                if (key === "c") { // Reset Center Offset (now also resets pan)
                    originX = 0;
                    originY = 0;
                    panChanged = true; // Will trigger updatePanFromInteraction
                    hasChanged = false;
                }
                if (key === "=" || key === "+") {
                    zoom(1 / zoomFactor, canvasWidth / 2, canvasHeight / 2);
                    hasChanged = false;
                }
                if (key === "-" || key === "_") {
                    zoom(zoomFactor, canvasWidth / 2, canvasHeight / 2);
                    hasChanged = false;
                }
            }

            // Update UI/LS for changed pan from keys
            if (panChanged) {
                updatePanFromInteraction();
            }
            // Save angles on key press
            if (hasChanged) {
                if (mode === "pendulum") {
                    setLocalStorageValue('pendulumAngle', pendulumAngle);
                } else {
                    setLocalStorageValue('startAngle', startAngle);
                }
            }

            // Redraw if not animating
            if (hasChanged && !shouldAnimate) {
                requestAnimationFrame(draw);
            }
        }



        // --- Zoom and Pan Implementation ---

        /**
         * Initializes zoom and pan event listeners (mouse and touch).
         */
        function initializeZoomAndPan() {
            const zoomInButton = document.getElementById('zoom-in');
            const zoomOutButton = document.getElementById('zoom-out');

            // Zoom button clicks
            zoomInButton.addEventListener('click', () => zoom(1 / zoomFactor, canvasWidth / 2, canvasHeight / 2));
            zoomOutButton.addEventListener('click', () => zoom(zoomFactor, canvasWidth / 2, canvasHeight / 2));

            // Mouse Wheel Zooming
            canvas.addEventListener('wheel', function (event) {
                event.preventDefault();
                const delta = event.deltaY > 0 ? zoomFactor : 1 / zoomFactor;
                const rect = canvas.getBoundingClientRect();
                const mouseX = event.clientX - rect.left;
                const mouseY = event.clientY - rect.top;
                zoom(delta, mouseX, mouseY);
            });

            // --- Touch Events for Mobile Pan and Pinch Zoom ---
            canvas.addEventListener('touchstart', (event) => {
                if (event.touches.length === 1) {
                    isDragging = true; isPinching = false;
                    const touch = event.touches[0];
                    lastX = touch.clientX; lastY = touch.clientY;
                    canvas.style.cursor = 'grabbing';
                } else if (event.touches.length === 2) {
                    isDragging = false; isPinching = true;
                    event.preventDefault();
                    const touch1 = event.touches[0]; const touch2 = event.touches[1];
                    pinchStartDistance = Math.hypot(touch1.clientX - touch2.clientX, touch1.clientY - touch2.clientY);
                }
            }, { passive: false });

            canvas.addEventListener('touchmove', (event) => {
                 event.preventDefault();
                if (event.touches.length === 1 && isDragging) {
                    const touch = event.touches[0];
                    const dx = touch.clientX - lastX; const dy = touch.clientY - lastY;
                    originX += dx; originY += dy;
                    lastX = touch.clientX; lastY = touch.clientY;
                    updatePanFromInteraction();
                } else if (event.touches.length === 2 && isPinching) {
                    const touch1 = event.touches[0]; const touch2 = event.touches[1];
                    const currentDistance = Math.hypot(touch1.clientX - touch2.clientX, touch1.clientY - touch2.clientY);
                    const rect = canvas.getBoundingClientRect();
                    const pinchCenterX = ((touch1.clientX + touch2.clientX) / 2) - rect.left;
                    const pinchCenterY = ((touch1.clientY + touch2.clientY) / 2) - rect.top;
                    if (pinchStartDistance > 0) {
                         const delta = pinchStartDistance / currentDistance;
                         zoom(delta, pinchCenterX, pinchCenterY);
                    }
                    pinchStartDistance = currentDistance;
                }
            }, { passive: false });

            canvas.addEventListener('touchend', (event) => {
                 if (event.touches.length < 2) { isPinching = false; pinchStartDistance = 0; }
                 if (event.touches.length < 1) { isDragging = false; canvas.style.cursor = 'grab'; }
             });

             canvas.addEventListener('touchcancel', (event) => {
                 isDragging = false; isPinching = false; pinchStartDistance = 0; canvas.style.cursor = 'grab';
             });

            // --- Mouse Drag Panning with Pointer Lock ---
            
            // Pointer lock change handler
            function handlePointerLockChange() {
                if (document.pointerLockElement === canvas) {
                    isPointerLocked = true;
                    canvas.style.cursor = 'none'; // Hide cursor when locked
                } else {
                    isPointerLocked = false;
                    canvas.style.cursor = isDragging ? 'grabbing' : 'grab';
                    // If we exit pointer lock while dragging, stop dragging
                    if (isDragging) {
                        isDragging = false;
                    }
                }
            }
            
            // Pointer lock error handler
            function handlePointerLockError() {
                console.warn('Pointer lock failed. Falling back to normal mouse handling.');
                isPointerLocked = false;
            }
            
            // Listen for pointer lock events
            document.addEventListener('pointerlockchange', handlePointerLockChange, false);
            document.addEventListener('pointerlockerror', handlePointerLockError, false);
            
            canvas.addEventListener('mousedown', function (event) {
                 if (event.button !== 0 || event.target !== canvas) return;
                isDragging = true; isPinching = false;
                
                // Request pointer lock when starting to drag
                canvas.requestPointerLock();
                
                if (!isPointerLocked) {
                    // Fallback: store initial position for non-pointer-lock mode
                    lastX = event.clientX; lastY = event.clientY;
                    canvas.style.cursor = 'grabbing';
                }
                event.preventDefault();
            });
            
            canvas.addEventListener('mousemove', function (event) {
                if (isDragging) {
                    let dx, dy;
                    
                    if (isPointerLocked) {
                        // Use movement deltas when pointer is locked
                        dx = event.movementX || 0;
                        dy = event.movementY || 0;
                    } else {
                        // Fallback: calculate deltas from position
                        dx = event.clientX - lastX;
                        dy = event.clientY - lastY;
                        lastX = event.clientX;
                        lastY = event.clientY;
                    }
                    
                    originX += dx;
                    originY += dy;
                    updatePanFromInteraction();
                }
            });
            
            window.addEventListener('mouseup', function (event) {
                 if (event.button === 0 && isDragging) {
                     isDragging = false;
                     
                     // Exit pointer lock when drag ends
                     if (isPointerLocked) {
                         document.exitPointerLock();
                     }
                     
                     canvas.style.cursor = 'grab';
                 }
            });
            
            canvas.addEventListener('mouseleave', function (event) {
                if (isDragging && !isPointerLocked) {
                    isDragging = false;
                    canvas.style.cursor = 'grab';
                }
                // Note: mouseleave won't fire when pointer is locked
            });

            canvas.style.cursor = 'grab';
        }

        /**
         * Helper function called after interactive panning (mouse/touch drag).
         * Updates sliders, clamps origin, saves to LS, and applies transform.
         */
        function updatePanFromInteraction() {
            // Clamping happens within updatePanSliderLimits, which is called by zoom
            // Only clamp if wheel is locked
            if (isWheelLocked) {
                // Clamp origin values to the pan slider's min/max range
                originX = Math.max(parseFloat(horizontalOffsetSlider.min), Math.min(originX, parseFloat(horizontalOffsetSlider.max)));
                originY = Math.max(parseFloat(verticalOffsetSlider.min), Math.min(originY, parseFloat(verticalOffsetSlider.max)));
            }

            // Update the slider positions to reflect the new pan origin
            horizontalOffsetSlider.value = originX;
            verticalOffsetSlider.value = originY;

            // Save the updated origin to localStorage
            setLocalStorageValue('originX', originX);
            setLocalStorageValue('originY', originY);

            // Apply the new transform to the canvas and redraw
            updateCanvasTransform();
        }

        /**
         * Applies zoom transformation centered around a specific point.
         * @param {number} delta - The zoom factor (e.g., 1.1 for zoom out, 1/1.1 for zoom in).
         * @param {number} pointX - The X coordinate of the zoom center (relative to canvas).
         * @param {number} pointY - The Y coordinate of the zoom center (relative to canvas).
         */
       function zoom(delta, pointX, pointY) {
            const newScale = Math.max(minScale, Math.min(scale * delta, maxScale)); // Apply zoom limits
            // Calculate how much the scale actually changed (might be clamped)
            const scaleChange = newScale / scale;
            if (Math.abs(scaleChange - 1) < 0.001) return; // Avoid tiny changes if scale is clamped

            // Adjust originX/Y so the point (pointX, pointY) remains fixed *relative* to the viewport
            originX = pointX - (pointX - originX) * scaleChange;
            originY = pointY - (pointY - originY) * scaleChange;

            scale = newScale; // Update the global scale

            // Recalculate pan limits based on new scale and update sliders/origin
            updatePanSliderLimits();

            // Update pan sliders to reflect potential origin change due to zoom pivot AND clamping
            updatePanFromInteraction(); // Calls updateCanvasTransform internally

            // setLocalStorageValue('scale', scale); // Optionally save scale
        }


        /**
         * Applies the current scale and origin translation to the canvas context
         * and requests a redraw.
         */
        function updateCanvasTransform() {
            // Apply the combined scale and translation transform
             context.setTransform(scale, 0, 0, scale, originX, originY);

            // Request redraw. If animating, the animation loop handles drawing.
            // If not animating, request a single frame draw.
            if (!shouldAnimate) {
                 requestAnimationFrame(draw);
            }
        }

        // --- Drawing Functions ---

        // Helper to get the logical center X (ignoring pan, as pan is in transform)
        function getLogicalCenterX() { return canvasWidth / 2; }
        // Helper to get the logical center Y
        function getLogicalCenterY() { return canvasHeight / 2; }


        /**
         * Draws the visualization in "Pendulum" mode.
         */
        function drawPendulum() {
            const centerX = getLogicalCenterX(); // Draw relative to logical center
            const centerY = getLogicalCenterY();
            const currentRadius = radius * 1.7 + arcOffset; // Effective radius of the circle outline

            // Draw main circle outline (adapts thickness/dash to zoom)
            context.strokeStyle = color3;
            context.lineWidth = Math.max(1, 4 / scale); // Keep outline somewhat consistent
            context.setLineDash([circleOutlineDashDensity / scale, circleOutlineDashDensity / scale]);
            context.beginPath();
            context.arc(centerX, centerY, currentRadius, 0, 2 * Math.PI);
            context.stroke();
            context.setLineDash([]); // Reset line dash

            // Calculate pendulum position
            const normalizedPendulumAngle = ((pendulumAngle % 360) + 360) % 360; // Ensure 0-360
            const angleRad = normalizedPendulumAngle * Math.PI / 180;
            const orbitRadius = radius * lineLength; // Use main radius and length factor

            const pendulumX = centerX + orbitRadius * Math.cos(angleRad);
            const pendulumY = centerY + orbitRadius * Math.sin(angleRad);

            // Draw line from center to pendulum (adapts thickness to zoom)
            context.beginPath();
            context.strokeStyle = color; // Line color
            context.lineWidth = Math.max(1, lineThickness / scale);
            context.moveTo(centerX, centerY);
            context.lineTo(pendulumX, pendulumY);
            context.stroke();

            // Draw pendulum circle (bob) - size does not scale aggressively
            context.beginPath();
            context.fillStyle = color2; // Pendulum bob color
            const bobRadius = Math.max(2, pendulumThickness / 2); // Keep bob size relatively constant on screen
            context.arc(pendulumX, pendulumY, bobRadius, 0, 2 * Math.PI);
            context.fill();

            // Draw angle text (font size remains constant on screen)
            const textDist = radius * textDistance;
            const textX = centerX + textDist * Math.cos(angleRad);
            const textY = centerY + textDist * Math.sin(angleRad);

            context.font = `${textSize}px Verdana`; // Use fixed pixel size
            context.textAlign = "center";
            context.textBaseline = "middle";
            context.fillStyle = textColor;

            context.save(); // Save context for potential text rotation/translation
            context.translate(textX, textY);
            // Optional: Rotate text radially context.rotate(angleRad + Math.PI / 2);
            context.fillText(angleName(normalizedPendulumAngle), 0, 0); // Draw at new (0,0)
            context.restore(); // Restore previous context state
        }

        /**
         * Draws the visualization in "Many Lines" mode.
         */
        function drawManyLines() {
            const centerX = getLogicalCenterX();
            const centerY = getLogicalCenterY();
            const currentRadius = radius * 1.7 + arcOffset;

            // Draw circle outline (adapts thickness/dash to zoom)
            context.strokeStyle = color3;
            context.lineWidth = Math.max(1, 4 / scale);
            context.setLineDash([circleOutlineDashDensity / scale, circleOutlineDashDensity / scale]);
            context.beginPath();
            context.arc(centerX, centerY, currentRadius, 0, 2 * Math.PI);
            context.stroke();
            context.setLineDash([]);

            // Text properties (font size fixed on screen)
            context.font = `${textSize}px Verdana`;
            context.textAlign = "center";
            context.textBaseline = "middle";

            // Line properties
            const lineStartDistance = radius * 0.0; // Start lines from center
            const lineEndDistance = radius * lineLength;
            const textDist = radius * textDistance;
            const numLines = parseInt(radiatingLineCount);
             if (numLines < 1) return; // Need at least 1 line
             const angleIncrement = (numLines > 1) ? (360 / numLines) : 0; // Avoid division by zero if numLines is 1
             const currentLineThickness = Math.max(1, lineThickness / scale); // Scale thickness

             // Determine the index of the line opposite the first one (index 0)
             // This only makes sense if the number of lines is even.
             const oppositeIndex = (numLines > 1 && numLines % 2 === 0) ? (numLines / 2) : -1; // Use -1 if no direct opposite

            for (let i = 0; i < numLines; i++) {
                 let angleDeg = (i * angleIncrement + startAngle);
                 let normalizedAngleDeg = ((angleDeg % 360) + 360) % 360; // Normalize 0-360
                 let angleRad = normalizedAngleDeg * Math.PI / 180;

                 // Calculate line points relative to logical center
                 let startX = centerX + lineStartDistance * Math.cos(angleRad);
                 let startY = centerY + lineStartDistance * Math.sin(angleRad);
                 let endX = centerX + lineEndDistance * Math.cos(angleRad);
                 let endY = centerY + lineEndDistance * Math.sin(angleRad);

                 // --- Color Logic ---
                 // Assign the special color (color2) to the first line (index 0)
                 // AND to its opposite line, but only if numLines is even.
                 const isDesignatedSpecialLine = (i === 0) || (oppositeIndex !== -1 && i === oppositeIndex);
                 context.strokeStyle = isDesignatedSpecialLine ? color2 : color;
                 // --- End Color Logic ---

                 // Draw the line
                 context.lineWidth = currentLineThickness;
                 context.beginPath();
                 context.moveTo(startX, startY);
                 context.lineTo(endX, endY);
                 context.stroke();

                 // Calculate and draw text
                 let textX = centerX + textDist * Math.cos(angleRad);
                 let textY = centerY + textDist * Math.sin(angleRad);
                 context.fillStyle = textColor;
                 context.save();
                 context.translate(textX, textY);
                 // Optional: context.rotate(angleRad + Math.PI / 2);
                 context.fillText(angleName(normalizedAngleDeg), 0, 0);
                 context.restore();
            }
        }

        /**
         * Draws the visualization in "Single Line" mode.
         */
        function drawSingleLine() {
            const centerX = getLogicalCenterX();
            const centerY = getLogicalCenterY();
            const currentRadius = radius * 1.7 + arcOffset;

            // Draw circle outline
            context.strokeStyle = color3;
            context.lineWidth = Math.max(1, 4 / scale);
            context.setLineDash([circleOutlineDashDensity / scale, circleOutlineDashDensity / scale]);
            context.beginPath();
            context.arc(centerX, centerY, currentRadius, 0, 2 * Math.PI);
            context.stroke();
            context.setLineDash([]);

            // Text properties
            context.font = `${textSize}px Verdana`;
            context.textAlign = "center";
            context.textBaseline = "middle";

            // Calculate angle and line properties
            let normalizedAngleDeg = ((startAngle % 360) + 360) % 360;
            let angleRad = normalizedAngleDeg * Math.PI / 180;
            const lineStartDistance = radius * 0.0;
            const lineEndDistance = radius * lineLength;
            const textDist = radius * textDistance;
            const currentLineThickness = Math.max(1, lineThickness / scale);

            // Calculate coordinates relative to logical center
            let startX = centerX + lineStartDistance * Math.cos(angleRad);
            let startY = centerY + lineStartDistance * Math.sin(angleRad);
            let endX = centerX + lineEndDistance * Math.cos(angleRad);
            let endY = centerY + lineEndDistance * Math.sin(angleRad);
            let textX = centerX + textDist * Math.cos(angleRad);
            let textY = centerY + textDist * Math.sin(angleRad);

            // Draw the single line using color2
            context.lineWidth = currentLineThickness;
            context.strokeStyle = color2; // Use color2 (designated "special" color)
            context.beginPath();
            context.moveTo(startX, startY);
            context.lineTo(endX, endY);
            context.stroke();

             // Draw the text
            context.fillStyle = textColor;
             context.save();
             context.translate(textX, textY);
             // Optional: context.rotate(angleRad + Math.PI / 2);
             context.fillText(angleName(normalizedAngleDeg), 0, 0);
             context.restore();
        }


        /**
         * Draws the visualization in "Anaglyph 3D" mode.
         * Renders separate views for the left (red) and right (cyan) eyes, offset horizontally.
         */
        function drawAnaglyph() {
            const centerX = getLogicalCenterX();
            const centerY = getLogicalCenterY();
            const currentRadius = radius * 1.7 + arcOffset;
            // Calculate pixel offset for depth based on slider, radius, and zoom
            // More depth effect when zoomed out, less when zoomed in.
            const baseDepthPixelOffset = (depthOffset / 2) * (radius * 0.01) / Math.sqrt(scale) ;

            // --- Draw Circle Outline (Once, neutrally or averaged) ---
            context.strokeStyle = color3;
            context.lineWidth = Math.max(1, 4 / scale);
            context.setLineDash([circleOutlineDashDensity / scale, circleOutlineDashDensity / scale]);
            context.beginPath();
            context.arc(centerX, centerY, currentRadius, 0, 2 * Math.PI);
            context.stroke();
            context.setLineDash([]);


            // Common properties
            context.font = `${textSize}px Verdana`;
            context.textAlign = "center";
            context.textBaseline = "middle";
            const lineStartDistance = radius * 0.0;
            const lineEndDistance = radius * lineLength;
            const textDist = radius * textDistance;
            const numLines = parseInt(radiatingLineCount);
             if (numLines < 1) return;
             const angleIncrement = numLines === 1 ? 0 : 360 / numLines;
             const currentLineThickness = Math.max(1, lineThickness / scale);

            // --- Draw Left Eye View (Red Filter) ---
            context.strokeStyle = anaglyphLeftColor;
            context.fillStyle = anaglyphLeftColor;
            context.lineWidth = currentLineThickness;
            const leftShift = -baseDepthPixelOffset; // Shift left

            for (let i = 0; i < numLines; i++) {
                let angleDeg = (i * angleIncrement + startAngle);
                 let normalizedAngleDeg = ((angleDeg % 360) + 360) % 360;
                 let angleRad = normalizedAngleDeg * Math.PI / 180;

                 // Calculate points shifted horizontally for left eye
                 let lStartX = centerX + lineStartDistance * Math.cos(angleRad) + leftShift; // Use different var names
                 let lStartY = centerY + lineStartDistance * Math.sin(angleRad); // No vertical shift in basic anaglyph
                 let lEndX = centerX + lineEndDistance * Math.cos(angleRad) + leftShift;
                 let lEndY = centerY + lineEndDistance * Math.sin(angleRad);
                 let lTextX = centerX + textDist * Math.cos(angleRad) + leftShift;
                 let lTextY = centerY + textDist * Math.sin(angleRad);

                // Draw line
                context.beginPath(); context.moveTo(lStartX, lStartY); context.lineTo(lEndX, lEndY); context.stroke();
                // Draw text
                 context.save(); context.translate(lTextX, lTextY); context.fillText(angleName(normalizedAngleDeg), 0, 0); context.restore();
            }


            // --- Draw Right Eye View (Cyan Filter) ---
            context.strokeStyle = anaglyphRightColor;
            context.fillStyle = anaglyphRightColor;
            // lineWidth is already set
            const rightShift = baseDepthPixelOffset; // Shift right

            for (let i = 0; i < numLines; i++) {
                 let angleDeg = (i * angleIncrement + startAngle);
                 let normalizedAngleDeg = ((angleDeg % 360) + 360) % 360;
                 let angleRad = normalizedAngleDeg * Math.PI / 180;

                 // Calculate points shifted horizontally for right eye
                 let rStartX = centerX + lineStartDistance * Math.cos(angleRad) + rightShift; // Use different var names
                 let rStartY = centerY + lineStartDistance * Math.sin(angleRad);
                 let rEndX = centerX + lineEndDistance * Math.cos(angleRad) + rightShift;
                 let rEndY = centerY + lineEndDistance * Math.sin(angleRad);
                 let rTextX = centerX + textDist * Math.cos(angleRad) + rightShift;
                 let rTextY = centerY + textDist * Math.sin(angleRad);

                // Draw line
                context.beginPath(); context.moveTo(rStartX, rStartY); context.lineTo(rEndX, rEndY); context.stroke();
                // Draw text
                context.save(); context.translate(rTextX, rTextY); context.fillText(angleName(normalizedAngleDeg), 0, 0); context.restore();
            }
        }


        // --- Main Draw Function ---
        /**
         * Clears the canvas respecting the current transform (zoom/pan)
         * and calls the appropriate mode-specific drawing function.
         */
        function draw() {
            context.save(); // Save the current zoomed/panned transform state
            // Temporarily reset transform to identity (un-zoomed, un-panned)
            context.setTransform(1, 0, 0, 1, 0, 0);
            // Clear the entire underlying canvas bitmap with the background color
            context.fillStyle = bgColor;
            context.fillRect(0, 0, canvasWidth, canvasHeight);
            context.restore(); // Restore the zoom/pan transform for drawing

            // Call the drawing function for the current mode
            if (mode === "many") drawManyLines();
            else if (mode === "single") drawSingleLine();
            else if (mode === "pendulum") drawPendulum();
            else if (mode === "anaglyph") drawAnaglyph();

            // DEBUG: Draw origin crosshair if needed
            /*
            context.save();
            context.setTransform(1, 0, 0, 1, 0, 0); // Use identity transform
            context.strokeStyle = 'lime'; context.lineWidth = 1; context.beginPath();
            context.moveTo(originX - 10, originY); context.lineTo(originX + 10, originY);
            context.moveTo(originX, originY - 10); context.lineTo(originX, originY + 10);
            context.stroke(); context.restore();
            */
        }


        // --- Animation and Autopilot Logic ---

        let animationFrameId = null;    // ID returned by requestAnimationFrame
        let shouldAnimate = false;      // Flag to control the animation loop
        let autopilot1Active = false;   // Is Autopilot 1 (random jump) running?
        let autopilot2Active = false;   // Is Autopilot 2 (smooth transition) running?
        let autopilotCenterShiftTimeout = null; // Timeout ID for AP1 jumps/AP2 start delay
        let rotationDirection = rotateClockwise ? 1 : -1; // -1 for CCW, 1 for CW

        // State for Autopilot 2 smooth transitions
        let isTransitioning = false;    // Is a smooth pan transition in progress?
        let transitionStartTime = 0;    // Timestamp when the current transition started
        let transitionDuration = 1000;  // Duration of the transition (calculated based on speed)
        let transitionStartX = 0;       // Starting originX for the transition
        let transitionStartY = 0;       // Starting originY for the transition
        let targetOriginX = originX;    // Target originX for the transition
        let targetOriginY = originY;    // Target originY for the transition


        /**
         * The main animation loop, requested via requestAnimationFrame.
         * Updates angles, handles smooth transitions, and redraws the scene.
         * @param {DOMHighResTimeStamp} timestamp - The timestamp provided by requestAnimationFrame.
         */
        let lastCheckedWidth = 0;
        let lastCheckedHeight = 0;

        function mainLoop(timestamp) {
            // Check for resize on every frame to handle browser zoom gracefully
            if (window.innerWidth !== lastCheckedWidth || window.innerHeight !== lastCheckedHeight) {
                lastCheckedWidth = window.innerWidth;
                lastCheckedHeight = window.innerHeight;
                handleResize();
            }

            // Update state only if animation is active (autopilot, etc.)
            if (shouldAnimate) {
                // 1. Update Animated State
                updateAnglesForAnimation(); // Update rotation based on velocity/direction

                if (autopilot2Active && isTransitioning) {
                    updateTransition(timestamp); // Update smooth pan position if active
                }
            }

            // 2. Draw the updated scene
            draw();

            // 3. Request the next frame to keep the loop running
            animationFrameId = requestAnimationFrame(mainLoop);
        }

        /**
         * Updates the startAngle or pendulumAngle based on rotationVelocity and direction.
         * Called within the animation loop.
         */
         function updateAnglesForAnimation() {
            // If user is manually rotating, let handleKeyPresses manage it.
            if (pressedKeys["a"] || pressedKeys["arrowleft"] || pressedKeys["d"] || pressedKeys["arrowright"]) {
                return; // Skip automatic update
            }

            // If no manual keys, proceed with automatic animation rotation
            const effectiveRotationVelocity = rotationVelocity * rotationDirection;
             if (mode === "pendulum") {
                 pendulumAngle += effectiveRotationVelocity;
                 // Maybe save LS less frequently, e.g., on autopilot stop?
                 // setLocalStorageValue('pendulumAngle', pendulumAngle);
             } else { // Many, Single, Anaglyph modes
                 startAngle += effectiveRotationVelocity;
                 // setLocalStorageValue('startAngle', startAngle);
             }
        }
        // --- Dark Mode ---
        /**
         * Applies or removes dark mode CSS classes to relevant elements.
         * @param {boolean} isDark - True to apply dark mode, false for light mode.
         */
        function applyDarkMode(isDark) {
            const darkModeIcon = toggleDarkModeButton.querySelector('i');
            const action = isDark ? 'add' : 'remove'; // Method to call on classList

            document.body.classList[action]('dark-mode-body');
            controlsContainer.classList[action]('dark-mode'); // Apply to container too
            controls.classList[action]('dark-mode');
            toggleMenuButton.classList[action]('dark-mode');
            // Apply to zoom buttons
             for (let button of document.getElementById('zoom-controls').children) {
                 button.classList[action]('dark-mode');
             }
            // Apply to Autopilot buttons explicitly if needed (should inherit via #controls.dark-mode)
            // toggleAutopilot1Button.classList[action]('dark-mode');
            // toggleAutopilot2Button.classList[action]('dark-mode');

            // Update icon and title
            if (isDark) {
                darkModeIcon.classList.remove('fa-sun'); darkModeIcon.classList.add('fa-moon');
                toggleDarkModeButton.title = "Switch to Light Mode";
            } else {
                darkModeIcon.classList.remove('fa-moon'); darkModeIcon.classList.add('fa-sun');
                toggleDarkModeButton.title = "Switch to Dark Mode";
            }
        }

        // Dark Mode Toggle Button Listener
        toggleDarkModeButton.addEventListener('click', () => {
            isDarkMode = !isDarkMode;
            setLocalStorageValue('isDarkMode', isDarkMode);
            applyDarkMode(isDarkMode);
        });

        // --- Autopilot Control Functions ---

        // Rotation Direction Checkbox Listeners
        rotateClockwiseToggle.addEventListener('change', () => {
            if (rotateClockwiseToggle.checked) {
                 rotationDirection = 1;
                 rotateCounterClockwiseToggle.checked = false; // Ensure mutual exclusivity
                 setLocalStorageValue('rotateClockwise', 'true');
                 setLocalStorageValue('rotateCounterclockwise', 'false');
            } else if (!rotateCounterClockwiseToggle.checked) {
                 rotateClockwiseToggle.checked = true; // Prevent unchecking both
            }
        });
        rotateCounterClockwiseToggle.addEventListener('change', () => {
             if (rotateCounterClockwiseToggle.checked) {
                 rotationDirection = -1;
                 rotateClockwiseToggle.checked = false;
                 setLocalStorageValue('rotateClockwise', 'false');
                 setLocalStorageValue('rotateCounterclockwise', 'true');
             } else if (!rotateClockwiseToggle.checked) {
                 // Correction: if you uncheck this, re-check the *other* one (clockwise)
                 rotateCounterClockwiseToggle.checked = false; // Uncheck self first
                 rotateClockwiseToggle.checked = true;        // Check the other
                 rotationDirection = 1;                      // Update direction
                 setLocalStorageValue('rotateClockwise', 'true');
                 setLocalStorageValue('rotateCounterclockwise', 'false');
             }
        });

        // Autopilot Speed Slider Listener (restarts autopilot to apply new speed)
        document.getElementById('autopilot-speed').addEventListener('input', function () {
            autopilotSpeed = parseInt(this.value);
            setLocalStorageValue('autopilotSpeed', autopilotSpeed);
             // Restart active autopilot to apply new speed/timing and check movement conditions
             if (autopilot1Active) { stopAutopilot1(); startAutopilot1(); }
             else if (autopilot2Active) { stopAutopilot2(); startAutopilot2(); }
        });

        // Autopilot Walk Range Slider Listener
        autopilotWalkRangeSlider.addEventListener('input', function () {
            autopilotWalkRange = parseInt(this.value);
            setLocalStorageValue('autopilotWalkRange', autopilotWalkRange);
            // Restart active autopilot to apply new range conditions
            if (autopilot1Active) { stopAutopilot1(); startAutopilot1(); }
            else if (autopilot2Active) { stopAutopilot2(); startAutopilot2(); }
        });

        /**
         * Updates the placeholder text for the 'special-line-color' label based on the current mode.
         */
        function updateTextPlaceholder() {
            const label = document.getElementById('special-line-color-label');
            const container = label.closest('div'); // Get parent div
            if(!container) return; // Safety check

            if (mode === "pendulum") label.textContent = "Pendulum Color:";
            else if (mode === "single") label.textContent = "Line Color:";
            else if (mode === "many") label.textContent = "Special Line Color:";
            else { label.textContent = "Special Line Color:"; } // Default
            // Ensure container visibility matches label relevance
             container.style.display = (mode === 'pendulum' || mode === 'single' || mode === 'many') ? 'block' : 'none';
        }

        /**
         * Toggles visibility of mode-specific controls in the panel.
         */
        function toggleControlVisibility() {
            // Get references to mode-specific containers
            const lineCountCont = document.getElementById('radiating-line-count-container');
            const lineColorCont = document.getElementById('line-color-container');
            // Special color is handled by updateTextPlaceholder's container logic
            const pendulumSizeCont = document.getElementById('pendulum-size-container');
            const anaglyphPickers = document.getElementById('anaglyph-color-pickers');
            const depthOffsetCont = document.getElementById('depth-offset-container');

            // Hide all first
            lineCountCont.style.display = 'none';
            lineColorCont.style.display = 'none';
            pendulumSizeCont.style.display = 'none';
            anaglyphPickers.style.display = 'none';
            depthOffsetCont.style.display = 'none';

            // Show based on current mode
            if (mode === 'many') {
                lineCountCont.style.display = 'block';
                lineColorCont.style.display = 'block'; // Show regular line color
            } else if (mode === 'single') {
                // No line count, no regular color needed
            } else if (mode === 'pendulum') {
                lineColorCont.style.display = 'block'; // For the connecting line
                pendulumSizeCont.style.display = 'block';
            } else if (mode === 'anaglyph') {
                lineCountCont.style.display = 'block';
                anaglyphPickers.style.display = 'block';
                depthOffsetCont.style.display = 'block';
            }
            // Call this AFTER setting display none/block for other containers
            updateTextPlaceholder(); // Ensures special color label/container hides/shows correctly
        }


        // --- Autopilot 1: Random Jump ---
        toggleAutopilot1Button.addEventListener('click', () => {
            if (!autopilot1Active) startAutopilot1(); else stopAutopilot1();
        });

        function startAutopilot1() {
            if (autopilot2Active) stopAutopilot2(); // Ensure mutually exclusive

            autopilot1Active = true;
            toggleAutopilot1Button.textContent = 'Stop Autopilot 1';
            toggleAutopilot1Button.classList.add('active');
            toggleAutopilot2Button.textContent = 'Start Autopilot 2'; // Reset other button
            toggleAutopilot2Button.classList.remove('active');

            // Only disable manual pan if autopilot should actually move
            if (shouldAutopilotMove()) {
                horizontalOffsetSlider.disabled = true; // Disable manual pan
                verticalOffsetSlider.disabled = true;
                scheduleNextJump_AP1(); // Start the jump sequence
            }

             // Start animation updates (main loop is always running)
             shouldAnimate = true;
        }

        function stopAutopilot1() {
            autopilot1Active = false;
            toggleAutopilot1Button.textContent = 'Start Autopilot 1';
            toggleAutopilot1Button.classList.remove('active');

            clearTimeout(autopilotCenterShiftTimeout); // Stop scheduled jump
            autopilotCenterShiftTimeout = null;

            horizontalOffsetSlider.disabled = false; // Re-enable manual pan
            verticalOffsetSlider.disabled = false;

             // Stop animation loop ONLY if AP2 is also inactive
             if (!autopilot2Active) { shouldAnimate = false; }
        }

        // Schedules the next jump for Autopilot 1
        function scheduleNextJump_AP1() {
             if (!autopilot1Active) return; // Stop if deactivated between schedule and execution
             if (!shouldAutopilotMove()) return; // Don't move if speed/range at minimum

             // Calculate delay based on speed (faster speed -> shorter delay)
             const baseDelay = 5000, minDelay = 500;
             const speedRange = 40 - 5, delayRange = baseDelay - minDelay;
             const delay = baseDelay - ((autopilotSpeed - 5) / speedRange) * delayRange;

             autopilotCenterShiftTimeout = setTimeout(() => {
                 if (!autopilot1Active) return; // Check again before jumping
                 if (!shouldAutopilotMove()) return; // Don't move if speed/range at minimum

                 const target = calculateAutopilotTargetOrigin(); // Get target pan values
                 originX = target.x; // Jump instantly
                 originY = target.y;

                 // Update UI Sliders and save state
                 updatePanFromInteraction(); // Updates sliders, saves LS, applies transform

                 scheduleNextJump_AP1(); // Schedule the *next* jump
             }, delay);
         }


        // --- Autopilot 2: Smooth Transition ---
        toggleAutopilot2Button.addEventListener('click', () => {
            if (!autopilot2Active) startAutopilot2(); else stopAutopilot2();
        });

        function startAutopilot2() {
             if (autopilot1Active) stopAutopilot1(); // Ensure mutually exclusive

            autopilot2Active = true;
            toggleAutopilot2Button.textContent = 'Stop Autopilot 2';
            toggleAutopilot2Button.classList.add('active');
            toggleAutopilot1Button.textContent = 'Start Autopilot 1';
            toggleAutopilot1Button.classList.remove('active');

            // Only disable manual pan if autopilot should actually move
            if (shouldAutopilotMove()) {
                horizontalOffsetSlider.disabled = true;
                verticalOffsetSlider.disabled = true;
                startNewTransition_AP2(); // Start the first transition
            }

             shouldAnimate = true;
        }

        function stopAutopilot2() {
             autopilot2Active = false;
             isTransitioning = false; // Stop any ongoing transition calculation
             toggleAutopilot2Button.textContent = 'Start Autopilot 2';
             toggleAutopilot2Button.classList.remove('active');

             horizontalOffsetSlider.disabled = false;
             verticalOffsetSlider.disabled = false;

             if (!autopilot1Active) { shouldAnimate = false; }
        }

        // Starts a new smooth transition for Autopilot 2
        function startNewTransition_AP2() {
            if (!autopilot2Active) return;
            if (!shouldAutopilotMove()) return; // Don't move if speed/range at minimum

            const target = calculateAutopilotTargetOrigin(); // Get target pan
            targetOriginX = target.x;
            targetOriginY = target.y;

            transitionStartX = originX; // Start from current pan position
            transitionStartY = originY;
            transitionStartTime = performance.now(); // Record start time

            // Calculate duration based on speed (faster speed -> shorter duration)
            const baseDuration = 4000, minDuration = 500;
            const speedRange = 40 - 5, durationRange = baseDuration - minDuration;
            transitionDuration = baseDuration - ((autopilotSpeed - 5) / speedRange) * durationRange;

            isTransitioning = true; // Flag that transition is active
            // The animation loop will now call updateTransition()
        }

        /**
         * Checks if autopilot should perform panning movements.
         * Returns false if autopilot speed is at minimum OR pan range is at minimum.
         * @returns {boolean} True if autopilot should move, false otherwise.
         */
        function shouldAutopilotMove() {
            return autopilotSpeed > 5 && autopilotWalkRange > 0;
        }

        /**
         * Calculates the target origin (pan) for autopilot movements based on
         * the autopilotWalkRange setting, current canvas dimensions, and the *current*
         * origin (pan position). Clamps the result within the valid pan limits.
         * @returns {{x: number, y: number}} The clamped target originX and originY.
         */
        function calculateAutopilotTargetOrigin() {
             const walkPercentage = autopilotWalkRange / 100;
             // Calculate max offset relative to the logical center (0,0) of the *panning space*
             const maxHorizontalShift = (canvasWidth / 2) * walkPercentage;
             const maxVerticalShift = (canvasHeight / 2) * walkPercentage;

             // Generate random target within the allowed shift range [-maxShift, +maxShift]
             let targetX = Math.random() * (maxHorizontalShift * 2) - maxHorizontalShift;
             let targetY = Math.random() * (maxVerticalShift * 2) - maxVerticalShift;

            // Clamp target to the absolute limits defined by the pan sliders
            const minH = parseFloat(horizontalOffsetSlider.min);
            const maxH = parseFloat(horizontalOffsetSlider.max);
            const minV = parseFloat(verticalOffsetSlider.min);
            const maxV = parseFloat(verticalOffsetSlider.max);

            targetX = Math.max(minH, Math.min(Math.round(targetX), maxH));
            targetY = Math.max(minV, Math.min(Math.round(targetY), maxV));

            return { x: targetX, y: targetY };
         }

        /**
         * Updates the originX/Y during a smooth Autopilot 2 transition.
         * Called by the animation loop.
         * @param {DOMHighResTimeStamp} currentTime - Timestamp from requestAnimationFrame.
         */
         function updateTransition(currentTime) {
             if (!isTransitioning || !autopilot2Active) {
                 isTransitioning = false;
                 return;
             }

             const elapsedTime = currentTime - transitionStartTime;
             let progress = Math.min(elapsedTime / transitionDuration, 1); // Progress 0 to 1

             // Apply easing for smooth start/end
             const easedProgress = easeInOutCubic(progress);

             // Interpolate origin based on progress
             originX = transitionStartX + (targetOriginX - transitionStartX) * easedProgress;
             originY = transitionStartY + (targetOriginY - transitionStartY) * easedProgress;

             // Update UI Sliders continuously during transition
             horizontalOffsetSlider.value = originX;
             verticalOffsetSlider.value = originY;
             // Avoid spamming localStorage during transition; save only at the end

             // Apply the transform to the canvas so the movement is visible
             updateCanvasTransform(); // Apply transform BEFORE draw in animation loop

             // Check if transition is complete
             if (progress >= 1) {
                 originX = targetOriginX; // Ensure exact final position
                 originY = targetOriginY;
                 horizontalOffsetSlider.value = originX; // Final UI update
                 verticalOffsetSlider.value = originY;
                 setLocalStorageValue('originX', originX); // Persist final position
                 setLocalStorageValue('originY', originY);

                 isTransitioning = false;

                 // Start the *next* transition immediately for continuous movement
                 if(autopilot2Active) { // Check if still active before starting next
                    startNewTransition_AP2();
                 }
             }
         }

        // --- Easing Function ---
        /**
         * Cubic ease-in-out function.
         * @param {number} t - Progress value (0 to 1).
         * @returns {number} Eased progress value (0 to 1).
         */
        function easeInOutCubic(t) {
            return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
         }

        // Start the main animation loop which also handles resize detection
        requestAnimationFrame(mainLoop);

    </script>
</body>

</html>
